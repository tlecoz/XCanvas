class ObjectLibrary {
    constructor() {
        this.nbObject = 0;
        if (!ObjectLibrary._instance) {
            ObjectLibrary._instance = this;
            this.objects = {};
            this.names = [];
            this.indexByName = [];
            this.objectById = [];
        }
        else {
            throw new Error("ObjectLibrary is a singleton. You must use ObjectLibrary.instance");
        }
    }
    registerObject(dataType, o) {
        if (ObjectLibrary.creatingObjectsAfterLoad) {
            //console.log("ObjectLibrary.creatingObjectsAfterLoad ",o);
            return "";
        }
        let id, typeId;
        if (!this.objects[dataType]) {
            this.indexByName[dataType] = typeId = this.names.length;
            this.names.push(dataType);
            this.objects[dataType] = {
                typeId: typeId,
                elements: [o]
            };
            id = 0;
        }
        else {
            var obj = this.objects[dataType];
            typeId = obj.typeId;
            id = obj.elements.length;
            obj.elements[id] = o;
        }
        var ID = typeId + "_" + id;
        this.objectById[this.nbObject++] = {
            type: typeId,
            ID: ID,
            value: o
        };
        return ID;
    }
    save(fileName = "test.txt") {
        var data = this.names.join(",") + "[####]";
        var i, len = this.nbObject;
        var o, dataString;
        for (i = 0; i < len; i++) {
            o = this.objectById[i];
            dataString = o.value.dataString;
            if (dataString != "") {
                //console.log(i,o.value);
                if (i != 0)
                    data += "[#]";
                data += o.ID + "[|]" + dataString;
            }
            else {
                //console.log("error : ",o.value)
            }
        }
        var xhr = new XMLHttpRequest();
        var params = "fileName=" + fileName + "&data=" + data;
        xhr.open("POST", "saveFile.php");
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                //console.log(xhr.responseText);
            }
        };
        xhr.send(params);
    }
    load(url, onLoaded = null) {
        var th = this;
        this.loadObjectsByID = [];
        ObjectLibrary.creatingObjectsAfterLoad = true;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "test.txt");
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                //console.log(xhr.responseText);
                //console.log("########### LOADED #####################")
                var datas = xhr.responseText;
                var t = datas.split("[####]");
                th.names = t[0].split(",");
                var i, len = th.names.length;
                for (i = 0; i < len; i++)
                    th.objects[th.names[i]] = { type: i, elements: [] };
                var objects = t[1].split("[#]");
                var dataString, infos;
                var className;
                var ID, instanceId, classId;
                len = objects.length;
                var temp = [];
                for (i = 0; i < len; i++) {
                    t = objects[i].split("[|]");
                    ID = t[0];
                    infos = ID.split("_");
                    classId = Number(infos[0]);
                    className = th.names[classId];
                    instanceId = Number(infos[1]);
                    dataString = t[1];
                    th.loadObjectsByID[ID] = temp[i] = { className: className, instanceId: instanceId, dataString: dataString };
                    //if(!th.objects[className]) th.objects[className] = {type:classId,elements:[]};
                    //th.objects[className].elements[instanceId] = eval(className).fromDataString(dataString)
                    //console.log(className+" : "+dataString);
                    //console.log(th.objects[className].elements[instanceId]);
                }
                var o;
                for (i = 0; i < len; i++) {
                    o = temp[i];
                    console.log(i, o.className, o.instanceId, o.dataString);
                    th.objects[o.className].elements[o.instanceId] = eval(o.className).fromDataString(o.dataString);
                }
                ObjectLibrary.creatingObjectsAfterLoad = false;
                //console.log("#########################")
                if (onLoaded)
                    onLoaded(xhr.responseText);
            }
        };
        xhr.send(null);
    }
    static get instance() {
        if (!ObjectLibrary._instance)
            new ObjectLibrary();
        return ObjectLibrary._instance;
    }
    get dataTypes() { return this.names; }
    getElementsByName(name) {
        //console.log("getElementsByName ",name)
        return this.objects[name].elements;
    }
    getObjectByRegisterId(registerId) {
        let t = registerId.split("_");
        let o = this.objects[this.names[Number(t[0])]].elements[Number(t[1])];
        if (o)
            return o;
        if (this.loadObjectsByID) {
            let obj = this.loadObjectsByID[registerId];
            if (obj) {
                //console.log("this.objects["+obj.className+"].elements["+obj.instanceId+"] = "+obj.dataString)
                this.objects[obj.className].elements[obj.instanceId] = o = eval(obj.className).fromDataString(obj.dataString);
                return o;
            }
        }
        return null;
    }
    static print() {
        var lib = ObjectLibrary.instance;
        var names = lib.dataTypes;
        var i, len = names.length;
        var name;
        for (i = 0; i < len; i++) {
            name = names[i];
            //console.log("nb "+name+" = "+lib.getElementsByName(name).length);
        }
    }
    static printElements(name) {
        var t = ObjectLibrary.instance.getElementsByName(name);
        var i, len = t.length;
        for (i = 0; i < len; i++)
            console.log(i, " => ", t[i]);
    }
}
ObjectLibrary.creatingObjectsAfterLoad = false;
//# sourceMappingURL=ObjectLibrary.js.map
class RegisterableObject {
    constructor() {
        this.___ID = ObjectLibrary.instance.registerObject(this.constructor.name, this);
    }
    get REGISTER_ID() { return this.___ID; }
    ;
    get dataString() {
        return "";
    }
}
//# sourceMappingURL=RegisterableObject.js.map

class EventDispatcher extends RegisterableObject {
    constructor() {
        super();
        this.customData = {};
        this.___dispatcherNames = [];
        this.___nbDispatcher = 0;
        this.___dispatcherActifById = [];
        this.___dispatcherFunctionById = [];
    }
    addEventListener(name, func, overrideExistingEventIfExists = false) {
        if (name == undefined || func == undefined)
            return;
        var nameId = this.___dispatcherNames.indexOf(name);
        if (nameId == -1) {
            this.___dispatcherActifById[this.___nbDispatcher] = false;
            this.___dispatcherFunctionById[this.___nbDispatcher] = [];
            nameId = this.___nbDispatcher;
            this.___dispatcherNames[this.___nbDispatcher++] = name;
        }
        if (overrideExistingEventIfExists)
            this.___dispatcherFunctionById[nameId] = [func];
        else
            this.___dispatcherFunctionById[nameId].push(func);
    }
    clearEvents() {
        this.___dispatcherNames = [];
        this.___nbDispatcher = 0;
        this.___dispatcherActifById = [];
        this.___dispatcherFunctionById = [];
    }
    removeEventListener(name, func = null) {
        var id = this.___dispatcherNames.indexOf(name);
        if (id == -1)
            return;
        if (!func) {
            this.___dispatcherFunctionById[id] = [];
            return;
        }
        var functions = this.___dispatcherFunctionById[id];
        var id2 = functions.indexOf(func);
        if (id2 == -1)
            return;
        functions.splice(id2, 1);
    }
    applyEvents(object = null) {
        var len = this.___dispatcherNames.length;
        if (0 == len)
            return;
        var i, j, len2;
        var funcs;
        for (i = 0; i < len; i++) {
            if (this.___dispatcherActifById[i] == true) {
                this.___dispatcherActifById[i] = false;
                funcs = this.___dispatcherFunctionById[i];
                if (funcs) {
                    len2 = funcs.length;
                    for (j = 0; j < len2; j++)
                        funcs[j](this, object, this.___dispatcherNames[i]);
                }
                else {
                    console.warn("EventDispatcher.applyEvents bug ? -> ", this.___dispatcherNames[i]);
                }
            }
        }
    }
    dispatchEvent(eventName) {
        if (!this.___dispatcherNames)
            return;
        var id = this.___dispatcherNames.indexOf(eventName);
        if (id == -1)
            return;
        this.___dispatcherActifById[id] = true;
        this.applyEvents(this);
    }
}
//# sourceMappingURL=EventDispatcher.js.map

//# sourceMappingURL=IDirty.js.map
class DirtyEventDispatcher extends RegisterableObject {
    constructor() {
        super();
        this.dirty = true;
        this.____eventStack = [];
    }
    addDirtyEventTarget(eventTarget) {
        if (this.____eventStack.lastIndexOf(eventTarget) == -1)
            this.____eventStack.push(eventTarget);
    }
    removeDirtyEventTarget(eventTarget) {
        const id = this.____eventStack.lastIndexOf(eventTarget);
        if (id != -1)
            this.____eventStack.splice(id, 1);
    }
    applyDirty() {
        let i, len = this.____eventStack.length;
        for (i = 0; i < len; i++)
            this.____eventStack[i].dirty = true;
    }
}
//# sourceMappingURL=DirtyEventDispatcher.js.map
class Browser {
    constructor() {
        if (!Browser._instance) {
            Browser._instance = this;
            Browser._canUseImageBitmap = createImageBitmap != undefined && createImageBitmap != null;
            Browser._canUseWorker = Worker != undefined && Worker != null;
            Browser._canUseOffscreenCanvas = window.OffscreenCanvas != undefined && window.OffscreenCanvas != null;
            var canvas = document.createElement("canvas");
            canvas.width = canvas.height = 1;
            createImageBitmap(canvas).then((bmp) => Browser.emptyImageBitmap = bmp);
        }
    }
    static get canUseImageBitmap() {
        if (!Browser._instance)
            new Browser();
        return Browser._canUseImageBitmap;
    }
    static get canUseWorker() {
        if (!Browser._instance)
            new Browser();
        return Browser._canUseWorker;
    }
    static get canUseOffscreenCanvas() {
        if (!Browser._instance)
            new Browser();
        return Browser._canUseOffscreenCanvas;
    }
}
Browser._canUseWorker = false;
Browser._canUseImageBitmap = false;
Browser._canUseOffscreenCanvas = false;
Browser.emptyImageBitmap = null;
//# sourceMappingURL=Browser.js.map
class MouseEvents {
}
MouseEvents.CLICK = "CLICK";
MouseEvents.DOUBLE_CLICK = "DOUBLE_CLICK";
MouseEvents.DOWN = "DOWN";
MouseEvents.UP = "UP";
MouseEvents.MOVE = "MOVE";
MouseEvents.OVER = "OVER";
MouseEvents.OUT = "OUT";
MouseEvents.WHEEL_UP = "WHEEL_UP";
MouseEvents.WHEEL_DOWN = "WHEEL_DOWN";
//# sourceMappingURL=MouseEvents.js.map
class Keyboard {
}
Keyboard.SPACE = 8;
Keyboard.TAB = 9;
Keyboard.ENTER = 13;
Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.ESCAPE = 27;
Keyboard.PAGE_UP = 33;
Keyboard.PAGE_DOWN = 34;
Keyboard.END = 35;
Keyboard.HOME = 36;
Keyboard.LEFT = 37;
Keyboard.UP = 38;
Keyboard.RIGHT = 39;
Keyboard.DOWN = 40;
Keyboard.INSERT = 45;
Keyboard.DELETE = 46;
Keyboard.NUM_0 = 48;
Keyboard.NUM_1 = 49;
Keyboard.NUM_2 = 50;
Keyboard.NUM_3 = 51;
Keyboard.NUM_4 = 52;
Keyboard.NUM_5 = 53;
Keyboard.NUM_6 = 54;
Keyboard.NUM_7 = 55;
Keyboard.NUM_8 = 56;
Keyboard.NUM_9 = 57;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.NUMPAD_0 = 96;
Keyboard.NUMPAD_1 = 97;
Keyboard.NUMPAD_2 = 98;
Keyboard.NUMPAD_3 = 99;
Keyboard.NUMPAD_4 = 100;
Keyboard.NUMPAD_5 = 101;
Keyboard.NUMPAD_6 = 102;
Keyboard.NUMPAD_7 = 103;
Keyboard.NUMPAD_8 = 104;
Keyboard.NUMPAD_9 = 105;
Keyboard.MULTIPLY = 106;
Keyboard.ADD = 107;
Keyboard.SUBSTRACT = 109;
Keyboard.DIVIDE = 111;
Keyboard.DECIMAL_POINT = 110;
//# sourceMappingURL=Keyboard.js.map
class Touche extends EventDispatcher {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.actif = false;
        this.firstPoint = false;
        this.swipeId = TouchSwipe.NOT_DEFINED_YET;
    }
    start(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.swipeId = TouchSwipe.NOT_DEFINED_YET;
        this.actif = true;
        this.startTime = new Date().getTime();
        this.dispatchEvent(TouchEvents.START);
    }
    end(x, y) {
        this.vx = x - this.x;
        this.vy = y - this.y;
        this.lifeTime = new Date().getTime() - this.startTime;
        this.x = x;
        this.y = y;
        this.actif = false;
        this.dispatchEvent(TouchEvents.END);
    }
    move(x, y) {
        this.vx = x - this.x;
        this.vy = y - this.y;
        if (this.swipeId != TouchSwipe.NOT_A_SWIPE) {
            var pi2 = Math.PI * 2;
            var pi_2 = Math.PI / 2;
            var a = (pi2 + Math.atan2(this.vy, this.vx) + Math.PI / 4) % pi2;
            var direction = Math.floor(a / pi_2);
            if (TouchSwipe.NOT_DEFINED_YET == this.swipeId)
                this.swipeId = direction;
            else if (this.swipeId != TouchSwipe.NOT_A_SWIPE && direction != this.swipeId)
                this.swipeId = TouchSwipe.NOT_A_SWIPE;
        }
        this.x = x;
        this.y = y;
        this.actif = true;
        this.dispatchEvent(TouchEvents.MOVE);
    }
    isTap(timeLimit) {
        return (new Date().getTime() - this.startTime) < timeLimit;
    }
}
//# sourceMappingURL=Touche.js.map
class TouchSwipe {
}
TouchSwipe.NOT_A_SWIPE = -2;
TouchSwipe.NOT_DEFINED_YET = -1;
TouchSwipe.SWIPE_RIGHT = 0;
TouchSwipe.SWIPE_DOWN = 1;
TouchSwipe.SWIPE_LEFT = 2;
TouchSwipe.SWIPE_UP = 3;
//# sourceMappingURL=TouchSwipe.js.map
class MouseControler extends EventDispatcher {
    constructor(canvas) {
        super();
        this.x = 0;
        this.y = 0;
        this.isDown = false;
        var th = this;
        var mc = this.htmlCanvas = canvas;
        mc.onmouseover = function (e) {
            th.getMouseXY(e);
            th.dispatchEvent(MouseEvents.OVER);
        };
        mc.onmouseout = function (e) {
            th.getMouseXY(e);
            th.dispatchEvent(MouseEvents.OUT);
        };
        mc.onmousedown = function (e) {
            th.getMouseXY(e);
            th.isDown = true;
            th.dispatchEvent(MouseEvents.DOWN);
        };
        mc.onmouseup = function (e) {
            th.getMouseXY(e);
            th.isDown = false;
            th.dispatchEvent(MouseEvents.UP);
        };
        mc.onclick = function (e) {
            th.getMouseXY(e);
            th.dispatchEvent(MouseEvents.CLICK);
        };
        mc.ondblclick = function (e) {
            th.getMouseXY(e);
            th.dispatchEvent(MouseEvents.DOUBLE_CLICK);
        };
        mc.onmousemove = function (e) {
            th.getMouseXY(e);
            th.dispatchEvent(MouseEvents.MOVE);
        };
        
    }
    down(x, y) {
        this.x = x;
        this.y = y;
        this.dispatchEvent(MouseEvents.DOWN);
    }
    move(x, y) {
        this.x = x;
        this.y = y;
        this.dispatchEvent(MouseEvents.MOVE);
    }
    up(x, y) {
        this.x = x;
        this.y = y;
        this.dispatchEvent(MouseEvents.UP);
    }
    click(x, y) {
        this.x = x;
        this.y = y;
        this.dispatchEvent(MouseEvents.CLICK);
    }
    doubleClick(x, y) {
        this.x = x;
        this.y = y;
        this.dispatchEvent(MouseEvents.DOUBLE_CLICK);
    }
    getMouseXY(e, disableMoveEvent = false) {
        //console.log(e)
        if (e)
            e.preventDefault();
        e = e || window.event;
        if (e.pageX == null && e.clientX != null) {
            var html = document.documentElement;
            var body = document.body;
            e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
            e.pageX -= html.clientLeft || 0;
            e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
            e.pageY -= html.clientTop || 0;
        }
        this.x = e.pageX - this.htmlCanvas.offsetLeft;
        this.y = e.pageY - this.htmlCanvas.offsetTop;
    }
}
//# sourceMappingURL=MouseControler.js.map

class KeyboardControler extends EventDispatcher {
    constructor() {
        super();
        this.keyCode = -1;
        this.isDown = [];
        for (var i = 0; i < 222; i++)
            this.isDown[i] = false;
        var th = this;
        document.addEventListener("keydown", function (e) {
            th.keyCode = e.keyCode;
            th.isDown[th.keyCode] = true;
            th.dispatchEvent(KeyboardEvents.KEY_DOWN);
            th.dispatchEvent(KeyboardEvents.CHANGED);
        });
        document.addEventListener("keyup", function (e) {
            th.keyCode = e.keyCode;
            th.isDown[th.keyCode] = false;
            th.dispatchEvent(KeyboardEvents.KEY_DOWN);
            th.dispatchEvent(KeyboardEvents.CHANGED);
        });
    }
    keyIsDown(keyCode) { return this.isDown[keyCode]; }
    ;
}
//# sourceMappingURL=KeyboardControler.js.map
class TouchControler extends EventDispatcher {
    constructor(htmlCanvas, mouseControler) {
        super();
        this.tapTimeLimit = 60;
        this.doubleTimeLimit = 300;
        this.swipeTimeLimit = 400;
        this.lastTapTime = 0;
        this.startDist = 0;
        this.startAngle = 0;
        this.zoom = 1;
        this.rotation = 0;
        this.firstPoint = null;
        this.secondPoint = null;
        this.actifPoints = [];
        this.touches = [];
        this.nbTouch = 0;
        this.lastTouch = null;
        this.mouse = mouseControler;
        this.htmlCanvas = htmlCanvas;
        var th = this;
        htmlCanvas.addEventListener("touchstart", function (e) {
            e.preventDefault();
            var t = e.changedTouches;
            var touch;
            var i, len = t.length;
            var touchId = 0;
            for (i = 0; i < len; i++) {
                touch = t[i];
                touchId = touch.identifier;
                th.touchX = touch.pageX;
                th.touchY = touch.pageY;
                if (undefined == th.touches[touchId])
                    th.touches[touchId] = th.lastTouch = new Touche();
                else
                    th.lastTouch = th.touches[touchId];
                th.lastTouch.start(th.touchX, th.touchY);
                if (th.nbTouch == 0) {
                    th.lastTouch.firstPoint = true;
                    th.firstPoint = th.lastTouch;
                }
                else if (th.nbTouch == 1) {
                    th.initSecondPoint(th.lastTouch);
                }
                th.actifPoints[th.nbTouch++] = th.lastTouch;
                th.dispatchEvent(TouchEvents.ADD_ONE_TOUCH);
                if (true == th.lastTouch.firstPoint) {
                    th.dispatchEvent(TouchEvents.START);
                    th.mouse.down(th.touchX, th.touchY);
                }
            }
        }, false);
        function touchEnd(e) {
            e.preventDefault();
            var t = e.changedTouches;
            var touch;
            var i, len = t.length;
            var touchId = 0;
            var lastTouch;
            var oldTouchId = Number.MAX_VALUE;
            for (i = 0; i < len; i++) {
                touch = t[i];
                touchId = touch.identifier;
                if (touchId == oldTouchId)
                    continue;
                oldTouchId = touchId;
                th.touchX = touch.pageX;
                th.touchY = touch.pageY;
                lastTouch = th.touches[touchId];
                lastTouch.end(lastTouch.x, lastTouch.y);
                th.nbTouch--;
                th.dispatchEvent(TouchEvents.LOSE_ONE_TOUCH);
                th.actifPoints.splice(th.actifPoints.lastIndexOf(lastTouch), 1);
                if (lastTouch.firstPoint == true) {
                    lastTouch.firstPoint = false;
                    th.dispatchEvent(TouchEvents.END);
                    th.mouse.up(lastTouch.x, lastTouch.y);
                    var time = new Date().getTime();
                    if (lastTouch.lifeTime < th.tapTimeLimit) {
                        if (time - th.lastTapTime < th.doubleTimeLimit) {
                            th.dispatchEvent(TouchEvents.DOUBLE_TAP);
                            th.mouse.doubleClick(th.touchX, th.touchY);
                            th.lastTapTime = 0;
                        }
                        else {
                            th.dispatchEvent(TouchEvents.TAP);
                            th.mouse.click(lastTouch.x, lastTouch.y);
                            th.lastTapTime = time;
                        }
                    }
                    else {
                        if (lastTouch.lifeTime > 80 && lastTouch.lifeTime < th.swipeTimeLimit) {
                            var swipeId = lastTouch.swipeId;
                            if (swipeId >= 0) {
                                if (0 == swipeId)
                                    th.dispatchEvent(TouchEvents.SWIPE_RIGHT);
                                else if (1 == swipeId)
                                    th.dispatchEvent(TouchEvents.SWIPE_DOWN);
                                else if (2 == swipeId)
                                    th.dispatchEvent(TouchEvents.SWIPE_LEFT);
                                else if (3 == swipeId)
                                    th.dispatchEvent(TouchEvents.SWIPE_UP);
                            }
                        }
                    }
                }
            }
        }
        htmlCanvas.addEventListener("touchend", touchEnd, false);
        htmlCanvas.addEventListener("touchleave", touchEnd, false);
        htmlCanvas.addEventListener("touchmove", function (e) {
            e.preventDefault();
            var t = e.changedTouches;
            var touch;
            var i, len = t.length;
            var touchId = 0;
            var lastTouch;
            for (i = 0; i < len; i++) {
                touch = t[i];
                touchId = touch.identifier;
                th.touchX = touch.pageX;
                th.touchY = touch.pageY;
                lastTouch = th.touches[touchId];
                lastTouch.move(th.touchX, th.touchY);
                th.dispatchEvent(TouchEvents.MOVE_ONE_TOUCH);
                if (lastTouch.firstPoint == true) {
                    th.dispatchEvent(TouchEvents.MOVE);
                    th.mouse.move(th.touchX, th.touchY);
                }
                if (th.nbTouch >= 2) {
                    var dx = th.secondPoint.x - th.firstPoint.x;
                    var dy = th.secondPoint.y - th.firstPoint.y;
                    var d = Math.sqrt(dx * dx + dy * dy);
                    var a = Math.atan2(dy, dx);
                    th.zoom = d / th.startDist;
                    th.rotation = a - th.startAngle;
                    th.dispatchEvent(TouchEvents.ZOOM_AND_ROTATE);
                }
            }
        }, false);
    }
    initSecondPoint(p) {
        this.secondPoint = p;
        var dx = p.x - this.firstPoint.x;
        var dy = p.y - this.firstPoint.y;
        this.startAngle = Math.atan2(dy, dx);
        this.startDist = Math.sqrt(dx * dx + dy * dy);
    }
}
//# sourceMappingURL=TouchControler.js.map
class BitmapData extends EventDispatcher {
    constructor(w = 1, h = 1, cssColor = null) {
        super();
        this.offsetX = 0;
        this.offsetY = 0;
        this.needsUpdate = false; // can be used from an external class
        this._maskTemp = null;
        this._filterTemp = null;
        this._imageData = null;
        this.pixelDataDirty = true;
        this.sourceUrl = null;
        if (!Browser.canUseOffscreenCanvas)
            this.canvas = document.createElement("canvas");
        else
            this.canvas = new window.OffscreenCanvas(w, h);
        console.warn("createBitmapData ", w, h);
        this.canvas.width = w;
        this.canvas.height = h;
        this.ctx = this.canvas.getContext("2d");
        this.pixel = BitmapPixel.instance;
        if (cssColor) {
            this.ctx.fillStyle = cssColor;
            this.ctx.fillRect(0, 0, w, h);
        }
    }
    get htmlCanvas() { return this.canvas; }
    get context() { return this.ctx; }
    saveData() {
        var o = {
            data: this.ctx.getImageData(0, 0, this.width, this.height),
            w: this.width,
            h: this.height
        };
        this._savedData = o;
    }
    restoreData(clearSavedData = true) {
        if (!this._savedData)
            return;
        this.canvas.width = this._savedData.w;
        this.canvas.height = this._savedData.h;
        this.putImageData(this._savedData.data, 0, 0);
        if (clearSavedData)
            this._savedData = null;
    }
    setPadding(left = 0, right = 0, top = 0, bottom = 0) {
        var abstract = BitmapData.abstractCanvas;
        var ctx = BitmapData.abstractContext;
        abstract.width = this.width;
        abstract.height = this.height;
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.drawImage(this.htmlCanvas, 0, 0);
        this.canvas.width = this.width + left + right;
        this.canvas.height = this.height + top + bottom;
        this.drawImage(abstract, left, top);
    }
    createImageBitmap() {
        return createImageBitmap(this.htmlCanvas, 0, 0, this.htmlCanvas.width, this.htmlCanvas.height);
    }
    get width() { return this.canvas.width; }
    set width(n) { this.canvas.width = n; }
    get height() { return this.canvas.height; }
    set height(n) { this.canvas.height = n; }
    getImageData(x, y, w, h) {
        this._imageData = this.ctx.getImageData(x, y, w, h);
        return this._imageData;
    }
    putImageData(data, x, y) {
        this.ctx.putImageData(data, x, y);
    }
    drawDisplayElement(displayElement, matrix = null) {
        this.context.save();
        if (matrix)
            this.context.setTransform(matrix);
        displayElement.renderStack.updateCache(this.context, displayElement);
        this.context.restore();
    }
    drawHtmlCode(htmlCodeSource, x, y, w, h) {
        
        var data = "<svg xmlns='http://www.w3.org/2000/svg' width='" + w + "' height='" + h + "'>" +
            "<foreignObject width='100%' height='100%'>" +
            "<div xmlns='http://www.w3.org/1999/xhtml'>" +
            htmlCodeSource +
            "</div>" +
            "</foreignObject>" +
            "</svg>";
        var DOMURL = self.URL || self;
        var img = new Image();
        var svg = new Blob([data], { type: "image/svg+xml;charset=utf-8" });
        var url = DOMURL.createObjectURL(svg);
        var context = this.context;
        img.onload = function () {
            context.drawImage(img, x, y);
            DOMURL.revokeObjectURL(url);
        };
        img.src = url;
    }
    
    clone() {
        var bd = new BitmapData(this.width, this.height);
        bd.context.drawImage(this.htmlCanvas, 0, 0, this.width, this.height);
        return bd;
    }
    resize(w, h, resultBd = null) {
        if (!resultBd)
            resultBd = this;
        var oldW = resultBd.width;
        var oldH = resultBd.height;
        var abstract = BitmapData.abstractCanvas;
        var ctx = BitmapData.abstractContext;
        abstract.width = w;
        abstract.height = h;
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(this.htmlCanvas, 0, 0, this.width, this.height, 0, 0, w, h);
        resultBd.width = w;
        resultBd.height = h;
        resultBd.clear();
        resultBd.context.drawImage(abstract, 0, 0, w, h);
        return resultBd;
    }
    resizeWithAntialazing(w, h, resultBd) {
        if (!resultBd)
            resultBd = this;
        if (w >= resultBd.width && h >= resultBd.height)
            return this.resize(w, h, resultBd);
        var oldW = resultBd.width;
        var oldH = resultBd.height;
        var abstract = BitmapData.abstractCanvas;
        var ctx = BitmapData.abstractContext;
        ctx.clearRect(0, 0, abstract.width, abstract.height);
        abstract.width = oldW;
        abstract.height = oldH;
        ctx.drawImage(this.htmlCanvas, 0, 0);
        var nbPass = 0;
        while (oldW / 2 > w || oldH / 2 > h) {
            if (oldW / 2 > w)
                oldW /= 2;
            if (oldH / 2 > h)
                oldH /= 2;
            ctx.clearRect(0, 0, abstract.width, abstract.height);
            abstract.width = oldW;
            abstract.height = oldH;
            if (nbPass++ == 0)
                ctx.drawImage(this.htmlCanvas, 0, 0, this.width, this.height, 0, 0, oldW, oldH);
            else
                ctx.drawImage(resultBd.htmlCanvas, 0, 0, this.width, this.height, 0, 0, oldW, oldH);
            resultBd.clear();
            resultBd.width = oldW;
            resultBd.height = oldH;
            resultBd.context.drawImage(abstract, 0, 0);
        }
        if (w != oldW || h != oldH) {
            resultBd.clear();
            resultBd.width = w;
            resultBd.height = h;
            resultBd.context.drawImage(abstract, 0, 0, abstract.width, abstract.height, 0, 0, w, h);
        }
        return resultBd;
    }
    
    get pixelView() {
        if (!this._imageData)
            this._imageData = this.context.getImageData(0, 0, this.width, this.height);
        return this.pixel.init(this._imageData.data, this.width, this.height);
    }
    tint(r, g, b, a = 1) {
        var temp = BitmapData.abstractCanvas;
        var tempCtx = BitmapData.abstractContext;
        if (temp.width != this.width || temp.height != this.height) {
            temp.width = this.width;
            temp.height = this.height;
        }
        else {
            tempCtx.clearRect(0, 0, this.width, this.height);
        }
        tempCtx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";
        tempCtx.fillRect(0, 0, this.width, this.height);
        tempCtx.globalCompositeOperation = "destination-atop";
        tempCtx.drawImage(this.htmlCanvas, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.drawImage(temp, 0, 0);
    }
    fillRect(x, y, w, h, cssColor) {
        this.context.fillStyle = cssColor;
        this.context.fillRect(x, y, w, h);
        this.pixelDataDirty = true;
    }
    get pixelData() {
        if (!this._imageData || this.pixelDataDirty)
            this._imageData = this.context.getImageData(0, 0, this.width, this.height);
        this.pixelDataDirty = false;
        this.pixels = this._imageData.data;
        return this.pixels;
    }
    getPixels(x, y, w, h) {
        return this.context.getImageData(x, y, w, h).data;
    }
    getPixel(x, y) {
        var id = (this.width * y + x) * 4;
        var p = this.pixelData;
        var o = this.pixel;
        o.r = p[id];
        o.g = p[id + 1];
        o.b = p[id + 2];
        o.a = p[id + 3];
        return o;
    }
    getPixelRGBIntColor(x, y) {
        var id = (this.width * y + x) * 4;
        var p = this.pixelData;
        return (p[id] << 16) | (p[id + 1] << 8) | p[id + 2];
    }
    getPixelRGBAIntColor(x, y) {
        var id = (this.width * y + x) * 4;
        var p = this.pixelData;
        return p[id + 3] << 24 | p[id] << 16 | p[id + 1] << 8 | p[id + 2];
    }
    getPixelRed(x, y) { return this.pixelData[(this.width * y + x) * 4]; }
    getPixelGreen(x, y) { return this.pixelData[(this.width * y + x) * 4 + 1]; }
    getPixelBlue(x, y) { return this.pixelData[(this.width * y + x) * 4 + 2]; }
    getPixelAlpha(x, y) { return this.pixelData[(this.width * y + x) * 4 + 3]; }
    clear() { this.context.clearRect(0, 0, this.width, this.height); }
    applyFilter(cssFilterStr) {
        this.context.filter = cssFilterStr;
        this.context.drawImage(this.htmlCanvas, 0, 0);
        this.context.filter = "";
    }
    drawImage(img, srcX = 0, srcY = 0, srcW = -1, srcH = -1, destX = 0, destY = 0, destW = -1, destH = -1) {
        if (srcW == -1) {
            srcW = img.width;
            srcH = img.height;
        }
        if (destW == -1) {
            destW = srcW;
            destH = srcH;
        }
        this.context.drawImage(img, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
        this.pixelDataDirty = true;
    }
    setImageData(imgData, x, y) {
        this._imageData = imgData;
        this.context.putImageData(imgData, x, y);
        this.pixelDataDirty = false;
    }
    applyImageData() {
        this.context.putImageData(this._imageData, 0, 0);
        this.pixelDataDirty = false;
    }
    //-------------FLOOD FILL ------------------------------------------------
    floodFillRGBAandReturnOutputCanvas(x, y, fillR, fillG, fillB, fillA = 255) {
        let outputCanvas = new BitmapData(this.width, this.height, 'rgba(0,0,0,0)');
        let outputDatas = outputCanvas.pixelData;
        let data = this.pixelData;
        var borderLen = 0;
        var borders = [];
        borders[0] = [{ x: x, y: y }];
        let currentBorder = borders[0];
        let nextBorder = currentBorder;
        let working = true;
        let i, nbPixel;
        let px, py, k;
        let bmpW = this.width, bmpH = this.height;
        let minX = 9999999, minY = 9999999, maxX = 0, maxY = 0;
        let id = (bmpW * y + x) * 4;
        let outputId;
        let r = data[id];
        let g = data[id + 1];
        let b = data[id + 2];
        let a = data[id + 3];
        data[id] = fillR;
        data[id + 1] = fillG;
        data[id + 2] = fillB;
        data[id + 3] = fillA;
        var w = this.width;
        var h = this.height;
        while (working) {
            currentBorder = nextBorder;
            borders[borderLen++] = nextBorder = [];
            nbPixel = currentBorder.length;
            k = 0;
            if (0 == nbPixel)
                working = false;
            for (i = 0; i < nbPixel; i++) {
                x = currentBorder[i].x;
                y = currentBorder[i].y;
                if (x < 0 || y < 0 || x >= w || y >= h)
                    continue;
                if (x > maxX)
                    maxX = x;
                if (x < minX)
                    minX = x;
                if (y > maxY)
                    maxY = y;
                if (y < minY)
                    minY = y;
                //if(x<0 || y<0) console.log("error = ",x,y);
                //topLeft
                px = x - 1;
                py = y - 1;
                //if(px >=0 && py >=0){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //top
                px = x;
                py = y - 1;
                //if(py >=0){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //topRight
                px = x + 1;
                py = y - 1;
                //if(py >=0 && px<=bmpW){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //right
                px = x + 1;
                py = y;
                //if(px <= bmpW){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottom right
                px = x + 1;
                py = y + 1;
                //if(px <= bmpW && py <= bmpH){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottom
                px = x;
                py = y + 1;
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottomLeft
                px = x - 1;
                py = y + 1;
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //left
                px = x - 1;
                py = y;
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = outputDatas[id] = fillR;
                    data[id + 1] = outputDatas[id + 1] = fillG;
                    data[id + 2] = outputDatas[id + 2] = fillB;
                    data[id + 3] = outputDatas[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
            }
        }
        this.applyImageData();
        outputCanvas.applyImageData();
        var w = maxX - minX;
        var h = maxY - minY;
        BitmapData.abstractCanvas.width = w;
        BitmapData.abstractCanvas.height = h;
        BitmapData.abstractContext.drawImage(outputCanvas.htmlCanvas, -minX, -minY);
        outputCanvas.width = w;
        outputCanvas.height = h;
        outputCanvas.context.drawImage(BitmapData.abstractCanvas, 0, 0);
        outputCanvas.offsetX = minX;
        outputCanvas.offsetY = minY;
        return outputCanvas;
    }
    floodFillRGBA(x, y, fillR, fillG, fillB, fillA = 255) {
        let data = this.pixelData;
        var borderLen = 0;
        var borders = [];
        borders[0] = [{ x: x, y: y }];
        let currentBorder = borders[0];
        let nextBorder = currentBorder;
        let working = true;
        let i, nbPixel;
        let px, py, k;
        let bmpW = this.width, bmpH = this.height;
        let minX = 9999999, minY = 9999999, maxX = 0, maxY = 0;
        let id = (bmpW * y + x) * 4;
        let r = data[id];
        let g = data[id + 1];
        let b = data[id + 2];
        let a = data[id + 3];
        data[id] = fillR;
        data[id + 1] = fillG;
        data[id + 2] = fillB;
        data[id + 3] = fillA;
        while (working) {
            currentBorder = nextBorder;
            borders[borderLen++] = nextBorder = [];
            nbPixel = currentBorder.length;
            k = 0;
            if (0 == nbPixel)
                working = false;
            for (i = 0; i < nbPixel; i++) {
                x = currentBorder[i].x;
                y = currentBorder[i].y;
                if (x > maxX)
                    maxX = x;
                if (x < minX)
                    minX = x;
                if (y > maxY)
                    maxY = y;
                if (y < minY)
                    minY = y;
                //topLeft
                px = x - 1;
                py = y - 1;
                //if(px >=0 && py >=0){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //top
                px = x;
                py = y - 1;
                //if(py >=0){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //topRight
                px = x + 1;
                py = y - 1;
                //if(py >=0 && px<=bmpW){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //right
                px = x + 1;
                py = y;
                //if(px <= bmpW){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottom right
                px = x + 1;
                py = y + 1;
                //if(px <= bmpW && py <= bmpH){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottom
                px = x;
                py = y + 1;
                //if(py <= bmpH){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //bottomLeft
                px = x - 1;
                py = y + 1;
                //if(px >= 0 && py <= bmpH){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
                //left
                px = x - 1;
                py = y;
                //if(px >= 0 && py <= bmpH){
                id = (bmpW * py + px) * 4;
                if (r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3]) {
                    data[id] = fillR;
                    data[id + 1] = fillG;
                    data[id + 2] = fillB;
                    data[id + 3] = fillA;
                    nextBorder[k++] = { x: px, y: py };
                }
                //}
            }
        }
        this.context.putImageData(this._imageData, 0, 0);
        this.pixelDataDirty = false;
        return { pixels: borders, bounds: new Rectangle2D(minX, minY, maxX, maxY) };
    }
    matchColor(x, y, r, g, b, a) {
        let data = this.pixelData;
        let id = (this.width * y + x) * 4;
        return r == data[id] && g == data[id + 1] && b == data[id + 2] && a == data[id + 3];
    }
    matchRed(x, y, value) { return value == this.pixelData[(this.width * y + x) * 4]; }
    matchGreen(x, y, value) { return value == this.pixelData[(this.width * y + x) * 4 + 1]; }
    matchBlue(x, y, value) { return value == this.pixelData[(this.width * y + x) * 4 + 2]; }
    matchAlpha(x, y, value) {
        //var v:number = this.pixelData[(this.w * y + x)*4+3];
        //if(v != 0 && v != 255) console.log(v);
        return value == this.pixelData[(this.width * y + x) * 4 + 3];
    }
    isOpaque(x, y) { return 255 == this.pixelData[(this.width * y + x) * 4 + 3]; }
    //---------- COLOR BOUND RECT --------------------------------
    getColorBoundRect(areaX, areaY, areaW, areaH, r, g, b, a, tolerance = 0, toleranceG = null, toleranceB = null, toleranceA = null) {
        let minX = 9999999, minY = 9999999, maxX = -99999999, maxY = -99999999;
        let p = this.getPixels(areaX, areaY, areaW, areaH);
        let i, len = p.length;
        let cr, cg, cb, ca, x, y, n;
        if (toleranceG == null)
            toleranceG = toleranceB = toleranceA = tolerance;
        else if (toleranceB == null) {
            toleranceB = tolerance;
            toleranceA = toleranceG;
        }
        else if (toleranceA == null)
            toleranceA = tolerance;
        for (i = 0; i < len; i += 4) {
            cr = p[i];
            cg = p[i + 1];
            cb = p[i + 2];
            ca = p[i + 3];
            if (cr >= r - tolerance && cr <= r + tolerance && cg >= g - toleranceG && cg <= g + toleranceG && cb >= b - toleranceB && cb <= b + toleranceB && ca >= a - toleranceA && ca <= a + toleranceA) {
                n = i * 0.25;
                x = i % areaW;
                y = (n / areaW) >> 0; // (val >> 0) ==> Math.floor
                if (x < minX)
                    minX = x;
                if (x > maxX)
                    maxX = x;
                if (y < minY)
                    minY = y;
                if (y > maxY)
                    maxY = y;
            }
        }
        if (minX == 9999999)
            return null;
        return { x: minX, y: minY, w: (maxX - minX), h: (maxY - minY) };
    }
    getRedChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax) {
        return this.getChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax, 0);
    }
    getGreenChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax) {
        return this.getChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax, 1);
    }
    getBlueChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax) {
        return this.getChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax, 2);
    }
    getAlphaChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax) {
        return this.getChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax, 3);
    }
    getChannelBoundRect(areaX, areaY, areaW, areaH, channelMin, channelMax, channelId = 3) {
        let minX = 9999999, minY = 9999999, maxX = -99999999, maxY = -99999999;
        let p = this.getPixels(areaX, areaY, areaW, areaH);
        let i, len = p.length;
        let c, x, y, n;
        let debug = "";
        for (i = 0; i < len; i += 4) {
            c = p[i + channelId];
            if (c >= channelMin && c <= channelMax) {
                n = i * 0.25;
                y = (n / areaW) >> 0; // (val >> 0) ==> Math.floor
                x = n % areaW;
                if (x < minX)
                    minX = x;
                if (x > maxX)
                    maxX = x;
                if (y < minY)
                    minY = y;
                if (y > maxY)
                    maxY = y;
            }
        }
        if (minX == 9999999 || (maxX - minX) == 0 || (maxY - minY) == 0)
            return null;
        return { x: minX, y: minY, w: (maxX - minX + 1), h: (maxY - minY + 1) };
    }
}
BitmapData.IMAGE_LOADED = "IMAGE_LOADED";
BitmapData.nameIndex = 0;
BitmapData.abstractCanvas = document.createElement("canvas");
BitmapData.abstractContext = BitmapData.abstractCanvas.getContext("2d");
//# sourceMappingURL=BitmapData.js.map

class Video extends BitmapData {
    constructor(w, h, url = "", muted = true, autoplay = true) {
        super(1, 1);
        this.playing = false;
        this.canPlay = false;
        this.useBitmapData = false;
        this.firstFrameRendered = false;
        this.oldTime = -10000;
        this.crop = true;
        this.loop = true;
        this.fps = 30;
        this.playerW = w;
        this.playerH = h;
        var video = this.video = document.createElement("video");
        video.style.visibility = "hidden";
        video.width = w;
        video.height = h;
        video.muted = muted;
        video.autoplay = autoplay;
        video.src = this.url = url;
        //### the code works but chrome become unstable if I use ImageBitmap => 19/01/2019
        this.useNativeBitmapData = true; //(Browser.canUseImageBitmap == false)
        //######
        var th = this;
        var started = false;
        video.onpause = function () { th.playing = false; };
        video.onwaiting = function () { th.playing = false; };
        video.onplay = function () { th.playing = true; };
        video.onended = function () {
            th.playing = false;
            if (th.loop)
                video.play();
        };
        video.oncanplay = function () {
            th.videoW = video.videoWidth;
            th.videoH = video.videoHeight;
            th.canPlay = true;
            if (!started && autoplay) {
                started = true;
                document.body.appendChild(video);
            }
            if (!th.firstFrameRendered)
                th.update();
        };
    }
    get dataString() {
        return [this.playerW,
            this.playerH,
            this.video.src,
            Number(this.video.muted),
            Number(this.video.autoplay),
            Number(this.crop),
            Number(this.loop),
            this.fps
        ].join(",");
    }
    static fromDataString(data) {
        let t = data.split(",");
        let v = new Video(Number(t[0]), Number(t[1]), t[2], t[3] == "1", t[4] == "1");
        v.crop = t[5] == "1";
        v.loop = t[6] == "1";
        v.fps = Number(t[7]);
        return v;
    }
    update() {
        if (this.playing || this.firstFrameRendered == false) {
            if (Math.abs(this.video.currentTime - this.oldTime) < (1 / this.fps))
                return;
            this.oldTime = this.video.currentTime;
            if (this.useBitmapData) {
                var s;
                var w = this.videoW;
                var h = this.videoH;
                var srcX = 0, srcY = 0;
                var srcW = w, srcH = h;
                var destX = 0, destY = 0;
                var destW = this.playerW, destH = this.playerH;
                s = w / this.playerW;
                w *= s;
                h *= s;
                if (!this.crop) {
                    s = this.playerH / h;
                    w *= s;
                    h *= s;
                    if (w > this.playerW) {
                        s = this.playerW / w;
                        w *= s;
                        h *= s;
                    }
                    destX = (this.playerW - w) * 0.5;
                    destY = (this.playerH - h) * 0.5;
                    destW = this.playerW - destX * 2;
                    destH = this.playerH - destY * 2;
                }
                else {
                    s = this.playerW / w;
                    w *= s;
                    h *= s;
                    if (h < this.playerH) {
                        s = this.playerH / h;
                        w *= s;
                        h *= s;
                    }
                    var scale = w / this.videoW;
                    srcX = (w - this.playerW) * 0.5 / scale;
                    srcY = (h - this.playerH) * 0.5 / scale;
                    srcW = this.videoW - srcX * 2;
                    srcH = this.videoH - srcY * 2;
                }
                //console.log(destX,destY,destW,destH)
                //console.log(this.video.width,this.video.height,this.playerW,this.playerH)
                this.context.drawImage(this.video, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                this.dispatchEvent(BitmapData.IMAGE_LOADED);
            }
            else {
                createImageBitmap(this.video).then((bmp) => {
                    //if(this.bmp) this.bmp.close();
                    this.bmp = bmp;
                    this.dispatchEvent(BitmapData.IMAGE_LOADED);
                });
            }
            return true;
        }
    }
    get htmlCanvas() {
        if (this.useBitmapData)
            return this.canvas;
        else {
            if (this.bmp)
                return this.bmp;
            return this.canvas;
        }
    }
    get useNativeBitmapData() { return this.useBitmapData; }
    set useNativeBitmapData(b) {
        if (this.useBitmapData != b) {
            if (b) {
                this.canvas.width = this.video.width;
                this.canvas.height = this.video.height;
            }
            else {
                this.canvas.width = this.canvas.height = 1;
            }
            this.useBitmapData = b;
        }
    }
    get ready() { return this.canPlay; }
    get htmlVideo() { return this.video; }
    play() {
        if (!document.body.contains(this.video))
            document.body.appendChild(this.video);
        this.video.play();
    }
    stop() {
        if (document.body.contains(this.video))
            document.body.removeChild(this.video);
        this.video.src = "";
    }
    seekPercent(pct) {
        this.video.currentTime = this.duration * pct;
    }
    seekTime(timeInSecond) {
        this.video.currentTime = timeInSecond;
    }
}
//# sourceMappingURL=Video.js.map
class Img extends BitmapData {
    constructor(url = "") {
        super();
        this._url = "";
        var th = this;
        var img = this._img = document.createElement("img");
        img.onload = function () {
            th.width = img.width;
            th.height = img.height;
            th.drawImage(img, 0, 0);
            if (th.onLoaded)
                th.onLoaded(img);
            th.dispatchEvent(Img.IMAGE_LOADED);
        };
        this.url = url;
    }
    get dataString() { return this.url; }
    static fromDataString(url) { return new Img(url); }
    get htmlImage() { return this._img; }
    get url() { return this._url; }
    set url(s) {
        if (s != this._url) {
            this._url = this._img.src = s;
        }
    }
}
//# sourceMappingURL=Img.js.map
class Pt2D {
    constructor(x = 0, y = 0, isCurveAnchor = false) {
        this.x = x;
        this.y = y;
        this.isCurveAnchor = isCurveAnchor;
    }
    equals(pt) { return this.x == pt.x && this.y == pt.y; }
    add(pt) { return new Pt2D(this.x + pt.x, this.y + pt.y); }
    ;
    substract(pt) { return new Pt2D(this.x - pt.x, this.y - pt.y); }
    multiply(pt) { return new Pt2D(this.x * pt.x, this.y * pt.y); }
    ;
    divide(pt) { return new Pt2D(this.x / pt.x, this.y / pt.y); }
    ;
    normalize() {
        let max = Math.sqrt(this.dot(this));
        return new Pt2D(this.x / max, this.y / max);
    }
    dot(pt) { return this.x * pt.x + this.y * pt.y; }
    ;
    greaterThan(pt) {
        return this.x > pt.x || this.x == pt.x && this.y > pt.y;
    }
    static distance(a, b) {
        let dx = a.x - b.x;
        let dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
Pt2D.X = new Pt2D(1, 0);
Pt2D.Y = new Pt2D(0, 1);
Pt2D.ZERO = new Pt2D(0, 0);
//# sourceMappingURL=Pt2D.js.map
class Align {
}
Align.TOP_LEFT = new Pt2D(0, 0);
Align.TOP_CENTER = new Pt2D(0.5, 0);
Align.TOP_RIGHT = new Pt2D(1, 0);
Align.CENTER_LEFT = new Pt2D(0, 0.5);
Align.CENTER = new Pt2D(0.5, 0.5);
Align.CENTER_RIGHT = new Pt2D(1, 0.5);
Align.BOTTOM_LEFT = new Pt2D(0, 1);
Align.BOTTOM_CENTER = new Pt2D(0.5, 1);
Align.BOTTOM_RIGHT = new Pt2D(1, 1);
//# sourceMappingURL=Align.js.map
class Rectangle2D {
    constructor(minX = 0, minY = 0, maxX = 0, maxY = 0) {
        this.init(minX, minY, maxX, maxY);
    }
    init(minX = 0, minY = 0, maxX = 0, maxY = 0) {
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
        return this;
    }
    get x() { return this.minX; }
    set x(n) { this.minX = n; }
    get y() { return this.minY; }
    set y(n) { this.minY = n; }
    get width() { return this.maxX - this.minX; }
    set width(n) { this.maxX = this.minX + n; }
    get height() { return this.maxY - this.minY; }
    set height(n) { this.maxY = this.minY + n; }
    clear() { this.x = this.y = this.width = this.height = 0; }
    draw(context) {
        context.save();
        context.strokeStyle = "#000000";
        context.rect(this.minX, this.minY, this.maxX - this.minX, this.maxY - this.minY);
        context.stroke();
        context.restore();
    }
}
//# sourceMappingURL=Rectangle2D.js.map
class RectBounds {
    constructor() {
        this.minX = Number.MAX_VALUE;
        this.minY = Number.MAX_VALUE;
        this.maxX = Number.MIN_VALUE;
        this.maxY = Number.MIN_VALUE;
        this.drawBounds = function (context2D) {
            context2D.save();
            context2D.beginPath();
            context2D.strokeStyle = "#000000";
            context2D.setTransform(1, 0, 0, 1, 0, 0);
            context2D.rect(this.x, this.y, this.width, this.height);
            context2D.stroke();
            context2D.restore();
        };
        this.points = [];
        this.nbPoint = 0;
        this.reset();
    }
    reset() {
        this.minX = Number.MAX_VALUE;
        this.minY = Number.MAX_VALUE;
        this.maxX = Number.MIN_VALUE;
        this.maxY = Number.MIN_VALUE;
    }
    addPoint(px, py, registerPoint = true) {
        if (px <= this.minX)
            this.minX = px;
        if (px >= this.maxX)
            this.maxX = px;
        if (py <= this.minY)
            this.minY = py;
        if (py >= this.maxY)
            this.maxY = py;
        if (registerPoint)
            this.points[this.nbPoint++] = new Pt2D(px, py);
    }
    addRect(minX, minY, maxX, maxY) {
        if (minX <= this.minX)
            this.minX = minX;
        if (maxX >= this.maxX)
            this.maxX = maxX;
        if (minY <= this.minY)
            this.minY = minY;
        if (maxY >= this.maxY)
            this.maxY = maxY;
    }
    get x() { return this.minX; }
    get y() { return this.minY; }
    get width() { return this.maxX - this.minX; }
    get height() { return this.maxY - this.minY; }
    static getBounds(xAxis, yAxis, w, h, rotation) {
        if (!RectBounds.rect)
            RectBounds.rect = new RectBounds();
        let r = RectBounds.rect;
        r.reset();
        let x0 = -xAxis;
        let y0 = -yAxis;
        let a0 = Math.atan2(y0, x0) + rotation;
        let d0 = Math.sqrt(x0 * x0 + y0 * y0);
        let x1 = -xAxis + w;
        let y1 = -yAxis;
        let a1 = Math.atan2(y1, x1) + rotation;
        let d1 = Math.sqrt(x1 * x1 + y1 * y1);
        let x2 = -xAxis + w;
        let y2 = -yAxis + h;
        let a2 = Math.atan2(y2, x2) + rotation;
        let d2 = Math.sqrt(x2 * x2 + y2 * y2);
        let x3 = -xAxis;
        let y3 = -yAxis + h;
        let a3 = Math.atan2(y3, x3) + rotation;
        let d3 = Math.sqrt(x3 * x3 + y3 * y3);
        r.addPoint(xAxis + Math.cos(a0) * d0, yAxis + Math.sin(a0) * d0);
        r.addPoint(xAxis + Math.cos(a1) * d1, yAxis + Math.sin(a1) * d1);
        r.addPoint(xAxis + Math.cos(a2) * d2, yAxis + Math.sin(a2) * d2);
        r.addPoint(xAxis + Math.cos(a3) * d3, yAxis + Math.sin(a3) * d3);
        return r;
    }
}
//# sourceMappingURL=RectBounds.js.map
class Matrix2D extends EventDispatcher {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
        this.xAxis = 0;
        this.yAxis = 0;
        this.rotation = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.width = 1;
        this.height = 1;
        this.offsetW = 0;
        this.offsetH = 0;
        this.savedMatrixs = [];
        this.matrix = new DOMMatrix();
    }
    get dataString() {
        var data = [this.x, this.y, this.xAxis, this.yAxis, this.rotation, this.scaleX, this.scaleY, this.width, this.height, this.offsetW, this.offsetH].join(",");
        data += "#";
        data += [this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f].join(",");
        return data;
    }
    static fromDataString(data, target = null) {
        var t = data.split("#");
        var p = t[0].split(",");
        var m = t[1].split(",");
        var o;
        if (!target)
            o = new Matrix2D();
        else
            o = target;
        o.x = Number(p[0]);
        o.y = Number(p[1]);
        o.xAxis = Number(p[2]);
        o.yAxis = Number(p[3]);
        o.rotation = Number(p[4]);
        o.scaleX = Number(p[5]);
        o.scaleY = Number(p[6]);
        o.width = Number(p[7]);
        o.height = Number(p[8]);
        o.offsetW = Number(p[9]);
        o.offsetH = Number(p[10]);
        o.domMatrix.a = Number(m[0]);
        o.domMatrix.b = Number(m[1]);
        o.domMatrix.c = Number(m[2]);
        o.domMatrix.d = Number(m[3]);
        o.domMatrix.e = Number(m[4]);
        o.domMatrix.f = Number(m[5]);
        return o;
    }
    save() {
        let o = this.savedMatrixs, next = null;
        if (o)
            next = o;
        var obj = {
            matrix: this.matrix.toString(),
            next: next
        };
        this.savedMatrixs = obj;
    }
    restore() {
        this.setMatrixValue(this.savedMatrixs.matrix);
        this.savedMatrixs = this.savedMatrixs.next;
    }
    get realWidth() {
        //must be overrided
        return this.width;
    }
    get realHeight() {
        //must be overrided
        return this.height;
    }
    clone() {
        var m = new Matrix2D();
        m.x = this.x;
        m.y = this.y;
        m.rotation = this.rotation;
        m.scaleX = this.scaleX;
        m.scaleY = this.scaleY;
        m.xAxis = this.xAxis;
        m.yAxis = this.yAxis;
        m.width = this.width;
        m.height = this.height;
        m.setMatrixValue(this.matrix.toString());
        return m;
    }
    applyTransform() {
        const m = this.matrix;
        m.translateSelf(this.x, this.y);
        m.rotateSelf(this.rotation);
        m.translateSelf(-this.xAxis * this.scaleX, -this.yAxis * this.scaleY);
        m.scaleSelf(this.width * this.scaleX, this.height * this.scaleY);
        return m;
    }
    setMatrixValue(s = "matrix(1, 0, 0, 1, 0, 0)") { return this.matrix.setMatrixValue(s); }
    translate(x, y) { return this.matrix.translateSelf(x, y); }
    rotate(angle) { return this.matrix.rotateSelf(angle); }
    scale(x, y) { return this.matrix.scaleSelf(x, y); }
    invert() { return this.matrix.invertSelf(); }
    rotateFromVector(x, y) { return this.matrix.rotateFromVectorSelf(x, y); }
    multiply(m) { this.matrix.multiplySelf(m.domMatrix); }
    preMultiply(m) { this.matrix.preMultiplySelf(m.domMatrix); }
    identity() { this.matrix.setMatrixValue("matrix(1, 0, 0, 1, 0, 0)"); }
    get domMatrix() { return this.matrix; }
}
Matrix2D.IDENTITY = new DOMMatrix("matrix(1, 0, 0, 1, 0, 0)");
//# sourceMappingURL=Matrix2D.js.map
class HolePathRemover {
    constructor() {
        this.debug = new BitmapData(window.innerWidth, window.innerHeight);
        HolePathRemover._instance = this;
    }
    static get instance() {
        if (!HolePathRemover._instance)
            new HolePathRemover();
        return HolePathRemover._instance;
    }
    drawQuads() {
    }
    drawPath(pct, color = "#000000") {
        var ctx = this.debug.context;
        this.debug.clear();
        ctx.fillStyle = color;
        var path = this.outside;
        var s = 1;
        ctx.beginPath();
        ctx.moveTo(path[0].x * s, path[0].y * s);
        var i, len = path.length * pct;
        for (i = 1; i < len; i++)
            ctx.lineTo(path[i].x * s, path[i].y * s);
        ctx.closePath();
        //ctx.fill("evenodd");
        ctx.stroke();
        for (i = 0; i < this.quads.length; i++) {
            ctx.fillStyle = "#ff0000";
            ctx.beginPath();
            ctx.moveTo(this.quads[i].p0.x * s, this.quads[i].p0.y * s);
            ctx.lineTo(this.quads[i].p1.x * s, this.quads[i].p1.y * s);
            ctx.lineTo(this.quads[i].p2.x * s, this.quads[i].p2.y * s);
            ctx.lineTo(this.quads[i].p3.x * s, this.quads[i].p3.y * s);
            ctx.closePath();
            ctx.fill();
        }
    }
    findClosestPoints(outside, hole) {
        var result = { outsidePt: null, holePt: null, dist: 9999999999999 };
        let i, j, nbHole = hole.length, nbOut = outside.length;
        let hx, hy, ox, oy, dx, dy;
        let holePt, outPt;
        for (i = 0; i < nbHole; i++) {
            holePt = hole[i];
            hx = holePt.x;
            hy = holePt.y;
            for (j = 0; j < nbOut; j++) {
                outPt = outside[j];
                ox = outPt.x;
                oy = outPt.y;
                dx = ox - hx;
                dy = oy - hy;
                outPt.dist = dx * dx + dy * dy;
            }
            outside = outside.sort(function (a, b) {
                if (a.dist > b.dist)
                    return 1;
                if (a.dist < b.dist)
                    return -1;
                return 0;
            });
            if (outside[0].dist < result.dist) {
                result.dist = outside[0].dist;
                result.outsidePt = outside[0];
                result.holePt = holePt;
            }
        }
        //console.log(result);
        return result;
    }
    init(outside, precision = 0) {
        this.quads = [];
        var minX = 9999999;
        var minY = 9999999;
        var maxX = -9999999;
        var maxY = -9999999;
        //####
        //console.log("precision = ",precision)
        //precision = 0.1
        if (precision != 0)
            outside = BorderVectorizer.instance.init(outside.length * precision >> 0, outside);
        //###
        var i, len = outside.length;
        var pt;
        var px, py;
        for (i = 0; i < len - 1; i++) {
            pt = outside[i];
            pt.id = i;
            px = pt.x;
            py = pt.y;
            if (px > maxX)
                maxX = px;
            if (px < minX)
                minX = px;
            if (py > maxY)
                maxY = py;
            if (py < minY)
                minY = py;
            pt.next = outside[(i + 1) % len];
            if (i > 0)
                pt.prev = outside[i - 1];
            else
                outside[i].prev = outside[len - 1];
        }
        var w = maxX - minX;
        var h = maxY - minY;
        var size = this.gridSize = (Math.max(w, h) / 8) >> 0;
        this.outside = outside;
        var nbX = Math.ceil(w / size);
        var nbY = Math.ceil(h / size);
        var j, k = 0;
        var grid = this.grid = [];
        var cells = this.cells = [];
        //var ctx = this.debug.context;
        //ctx.strokeStyle = "rgba(255,0,0,0.5)"
        //ctx.lineWidth = 0.1;
        //ctx.beginPath()
        for (i = 0; i < nbX; i++) {
            //tx.moveTo(i*size,0);
            //ctx.lineTo(i*size,h);
            //ctx.closePath()
            //ctx.stroke()
            grid[i] = [];
            for (j = 0; j < nbY; j++) {
                //if(i==0){
                //  ctx.beginPath()
                //ctx.moveTo(0,j*size);
                //ctx.lineTo(w,j*size);
                //ctx.closePath()
                //}
                grid[i][j] = cells[k++] = [];
                grid[i][j].x = i;
                grid[i][j].y = j;
                grid[i][j].used = false;
            }
        }
        //ctx.stroke()
        //ctx.lineWidth = 1
        for (i = 0; i < len - 1; i++) {
            pt = outside[i];
            px = pt.x;
            py = pt.y;
            grid[(px / size) >> 0][(py / size) >> 0].push(pt);
        }
    }
    getCellAround(px, py, result) {
        var x = px, y = py;
        var grid = this.grid;
        x = px - 1;
        y = py - 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px + 0;
        y = py - 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px + 1;
        y = py - 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px + 1;
        y = py + 0;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px + 1;
        y = py + 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px + 0;
        y = py + 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px - 1;
        y = py + 1;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
        x = px - 1;
        y = py - 0;
        if (grid[x] && grid[x][y] && !grid[x][y].used) {
            grid[x][y].used = true;
            result.push(grid[x][y]);
        }
    }
    findClosestPoints2(hole) {
        var result;
        var i, len = hole.length;
        var pt, px, py;
        var grid = this.grid;
        var size = this.gridSize;
        var points = [];
        var o;
        for (i = 0; i < this.cells.length; i++)
            this.cells[i].used = false;
        var around = [];
        for (i = 0; i < len; i++) {
            pt = hole[i];
            px = (pt.x / size) >> 0;
            py = (pt.y / size) >> 0;
            o = grid[px][py];
            o.used = true;
            points = points.concat(o);
            if (points.length == 0)
                this.getCellAround(px, py, around);
            //else break;
        }
        //console.log()
        var a;
        var newAround;
        var k = 0;
        while (points.length == 0 && k++ < 1000) {
            len = around.length;
            newAround = [];
            for (i = 0; i < len; i++) {
                a = around[i];
                a.used = true;
                points = points.concat(a);
                if (points.length == 0)
                    this.getCellAround(a.x, a.y, newAround);
                //else break;
            }
            around = newAround;
        }
        return this.findClosestPoints(points, hole);
    }
    addHole(hole, precision = 0) {
        var time = new Date().getTime();
        //###
        if (precision != 0)
            hole = BorderVectorizer.instance.init(hole.length * precision >> 0, hole);
        //###
        var i, len = hole.length;
        for (i = 0; i < len; i++) {
            hole[i].id = i;
            hole[i].prev = hole[(i + 1) % len];
            if (i > 0)
                hole[i].next = hole[i - 1];
            else
                hole[i].next = hole[len - 1];
            //console.log(i,hole[i].prev,hole[i].next)
        }
        //hole[len-1].next = hole[0];
        //console.log("---")
        var o = this.findClosestPoints2(hole.concat());
        //console.log(o)
        var outside = this.outside;
        var id = o.outsidePt.id - 1;
        if (id < 0)
            id += outside.length;
        var outConnectStartPt = outside[id];
        var outConnectEndPt = outside[(o.outsidePt.id + 1) % outside.length];
        //var outErasedPt:BorderPt = outside.splice(o.outsidePt.id,1)[0];
        var holeConnectStartPt = hole[o.holePt.id];
        //console.log("outConnectStartPt = ",outConnectStartPt)
        //console.log("holeConnectStartPt = ",holeConnectStartPt)
        var id = o.holePt.id - 1;
        if (id < 0)
            id += hole.length;
        var holeConnectEndPt = hole[id];
        //var holeErasedPt:BorderPt = hole.splice(o.holePt.id,1)[0];
        outConnectStartPt.next = holeConnectEndPt;
        holeConnectStartPt.next = outConnectEndPt;
        this.quads.push({
            p0: outConnectStartPt,
            p1: outConnectEndPt,
            p2: holeConnectStartPt,
            p3: holeConnectEndPt
        });
        var path = [];
        var first = outside[0];
        var k = 0;
        var pt = path[k++] = first;
        pt.id = 0;
        pt = pt.next;
        while (pt && pt != first) {
            pt.id = k;
            path[k++] = pt;
            pt = pt.next;
        }
        //console.log("k = ",k)
        this.outside = path;
        //this.drawPath(path,"#000000");
        //this.drawPath(hole,"#ff0000");
        //console.log(new Date().getTime()-time)
        return path;
    }
}
//# sourceMappingURL=HolePathRemover.js.map
class EarCutting {
    constructor() {
        this.CONCAVE = -1;
        this.TANGENTIAL = 0;
        this.CONVEX = 1;
        this._computeTriangles = function (arrayXY, offset, count) {
            this.vertices = arrayXY;
            this.vertexCount = count / 2;
            this.indices = [];
            var i, n;
            if (this.areVerticesClockwise(this.vertices, offset, count))
                for (i = 0; i < this.vertexCount; i++)
                    this.indices[i] = i;
            else
                for (i = 0, n = this.vertexCount - 1; i < this.vertexCount; i++)
                    this.indices[i] = (n - i); // Reversed.
            this.vertexTypes = [];
            for (i = 0, n = this.vertexCount; i < n; ++i)
                this.vertexTypes[i] = this.classifyVertex(i);
            this.triangles = [];
            this.triangulate();
            return this.triangles;
        };
        if (EarCutting._instance)
            throw new Error("You must use EarCutting.instance");
        EarCutting._instance = this;
        this.vertexTypes = [];
        this.triangles = [];
    }
    static get instance() {
        if (!EarCutting._instance)
            new EarCutting();
        return EarCutting._instance;
    }
    computeSpannedAreaSign(p1x, p1y, p2x, p2y, p3x, p3y) {
        var area = p1x * (p3y - p2y);
        area += p2x * (p1y - p3y);
        area += p3x * (p2y - p1y);
        if (area < 0)
            return -1;
        else if (area > 0)
            return 1;
        else
            return 0;
    }
    previousIndex(index) { return (index == 0 ? this.vertexCount : index) - 1; }
    nextIndex(index) { return (index + 1) % this.vertexCount; }
    classifyVertex(index) {
        let previous = this.indices[this.previousIndex(index)] * 2;
        let current = this.indices[index] * 2;
        let next = this.indices[this.nextIndex(index)] * 2;
        return this.computeSpannedAreaSign(this.vertices[previous], this.vertices[previous + 1], this.vertices[current], this.vertices[current + 1], this.vertices[next], this.vertices[next + 1]);
    }
    areVerticesClockwise(vertices, offset, count) {
        if (count <= 2)
            return false;
        let area = 0, p1x, p1y, p2x, p2y;
        let i, n;
        for (i = offset, n = offset + count - 3; i < n; i += 2) {
            p1x = vertices[i];
            p1y = vertices[i + 1];
            p2x = vertices[i + 2];
            p2y = vertices[i + 3];
            area += p1x * p2y - p2x * p1y;
        }
        p1x = vertices[count - 2];
        p1y = vertices[count - 1];
        p2x = vertices[0];
        p2y = vertices[1];
        return area + p1x * p2y - p2x * p1y < 0;
    }
    isEarTip(earTipIndex) {
        if (this.vertexTypes[earTipIndex] == this.CONCAVE)
            return false;
        let _previousIndex = this.previousIndex(earTipIndex);
        let _nextIndex = this.nextIndex(earTipIndex);
        let p1 = this.indices[_previousIndex] * 2;
        let p2 = this.indices[earTipIndex] * 2;
        let p3 = this.indices[_nextIndex] * 2;
        let p1x = this.vertices[p1], p1y = this.vertices[p1 + 1];
        let p2x = this.vertices[p2], p2y = this.vertices[p2 + 1];
        let p3x = this.vertices[p3], p3y = this.vertices[p3 + 1];
        let i, v;
        let vx, vy;
        // Check if any point is inside the triangle formed by previous, current and next vertices.
        // Only consider vertices that are not part of this triangle, or else we'll always find one inside.
        for (i = this.nextIndex(_nextIndex); i != _previousIndex; i = this.nextIndex(i)) {
            // Concave vertices can obviously be inside the candidate ear, but so can tangential vertices
            // if they coincide with one of the triangle's vertices.
            if (this.vertexTypes[i] != this.CONVEX) {
                v = this.indices[i] * 2;
                vx = this.vertices[v];
                vy = this.vertices[v + 1];
                // Because the polygon has clockwise winding order, the area sign will be positive if the point is strictly inside.
                // It will be 0 on the edge, which we want to include as well.
                // note: check the edge defined by p1->p3 first since this fails _far_ more then the other 2 checks.
                if (this.computeSpannedAreaSign(p3x, p3y, p1x, p1y, vx, vy) >= 0) {
                    if (this.computeSpannedAreaSign(p1x, p1y, p2x, p2y, vx, vy) >= 0) {
                        if (this.computeSpannedAreaSign(p2x, p2y, p3x, p3y, vx, vy) >= 0)
                            return false;
                    }
                }
            }
        }
        return true;
    }
    findEarTip() {
        let i;
        for (i = 0; i < this.vertexCount; i++)
            if (this.isEarTip(i))
                return i;
        for (i = 0; i < this.vertexCount; i++)
            if (this.vertexTypes[i] != this.CONCAVE)
                return i;
        return 0; // If all vertices are concave, just return the first one.
    }
    cutEarTip(earTipIndex) {
        this.triangles.push(this.indices[this.previousIndex(earTipIndex)]);
        this.triangles.push(this.indices[earTipIndex]);
        this.triangles.push(this.indices[this.nextIndex(earTipIndex)]);
        this.indices.splice(earTipIndex, 1);
        this.vertexTypes.splice(earTipIndex, 1);
        this.vertexCount--;
    }
    triangulate() {
        let earTipIndex = 0;
        let _previousIndex = 0;
        let _nextIndex = 0;
        while (this.vertexCount > 3) {
            earTipIndex = this.findEarTip();
            this.cutEarTip(earTipIndex);
            // The type of the two vertices adjacent to the clipped vertex may have changed.
            _previousIndex = this.previousIndex(earTipIndex);
            _nextIndex = earTipIndex == this.vertexCount ? 0 : earTipIndex;
            this.vertexTypes[_previousIndex] = this.classifyVertex(_previousIndex);
            this.vertexTypes[_nextIndex] = this.classifyVertex(_nextIndex);
        }
        if (this.vertexCount == 3) {
            this.triangles.push(this.indices[0]);
            this.triangles.push(this.indices[1]);
            this.triangles.push(this.indices[2]);
        }
    }
    computeTriangles(arrayXY) {
        return this._computeTriangles(arrayXY, 0, arrayXY.length);
    }
}
//# sourceMappingURL=EarCutting.js.map
class BitmapPixel {
    constructor() {
        if (BitmapPixel._instance)
            throw new Error("You must use BitmapPixel.instance");
        BitmapPixel._instance = this;
    }
    static get instance() {
        if (!BitmapPixel._instance)
            new BitmapPixel();
        return BitmapPixel._instance;
    }
    init(pixelData, w, h) {
        this.w = w;
        this.h = h;
        this.pixelData = pixelData;
        return this;
    }
    getPixelObject(x, y) {
        this.id = (y * this.w + x) * 4;
        return this;
    }
    setRGB(x, y, r, g, b) {
        var id = (y * this.w + x) * 4;
        this.pixelData[id++] = r;
        this.pixelData[id++] = g;
        this.pixelData[id++] = b;
        this.pixelData[id++] = 255;
    }
    setRGBA(x, y, r, g, b, a) {
        var id = (y * this.w + x) * 4;
        this.pixelData[id++] = r;
        this.pixelData[id++] = g;
        this.pixelData[id++] = b;
        this.pixelData[id++] = a;
    }
    setSolidColorPixel(x, y, solidColor) {
        var id = (y * this.w + x) * 4;
        this.pixelData[id++] = solidColor.r;
        this.pixelData[id++] = solidColor.g;
        this.pixelData[id++] = solidColor.b;
        this.pixelData[id++] = solidColor.a;
    }
    copyIntoSolidColor(x, y, solidColor) {
        var id = (y * this.w + x) * 4;
        solidColor.r = this.pixelData[id++];
        solidColor.b = this.pixelData[id++];
        solidColor.g = this.pixelData[id++];
        solidColor.a = this.pixelData[id++];
    }
    get r() { return this.pixelData[this.id]; }
    get g() { return this.pixelData[this.id + 1]; }
    get b() { return this.pixelData[this.id + 2]; }
    get a() { return this.pixelData[this.id + 3]; }
    set r(n) { this.pixelData[this.id] = n; }
    set g(n) { this.pixelData[this.id + 1] = n; }
    set b(n) { this.pixelData[this.id + 2] = n; }
    set a(n) { this.pixelData[this.id + 3] = n; }
}
//# sourceMappingURL=BitmapPixel.js.map
class SolidColor extends EventDispatcher {
    constructor(r, g = null, b = null, a = 1) {
        super();
        this.useAlpha = false;
        //r can contains these values :
        //-> 0...255 => as the red component
        //-> 0xrrggbb => RGB hex number
        //-> 0xaarrggbb
        //-> "#rrggbb"
        //--> "#aarrggbb"
        console.warn("new SolidColor ", r, g, b, a);
        var red;
        if (g == null) {
            if (typeof (r) == "string") {
                var s = r.split("#").join("0x");
                //console.log(s);
                r = Number(s);
            }
            var color = r;
            if (r > 0xffffff) { //useAlpha
                a = color >>> 24;
                red = color >>> 16 & 0xFF;
                g = color >>> 8 & 0xFF;
                b = color & 0xFF;
            }
            else {
                red = color >> 16;
                g = color >> 8 & 0xFF;
                b = color & 0xFF;
                a = 1;
                console.log("aaa ", red, g, b);
            }
        }
        if (isNaN(red))
            red = r;
        this._r = red;
        this._g = g;
        this._b = b;
        this._a = a;
        this.updateStyle();
    }
    clone() { return new SolidColor(this._r, this._g, this._b, this._a); }
    get dataString() {
        return this._r + "," + this._g + "," + this._b + "," + this._a;
    }
    static fromDataString(data) {
        const t = data.split(",");
        return new SolidColor(Number(t[0]), Number(t[1]), Number(t[2]), Number(t[3]));
    }
    get r() { return this._r; }
    set r(n) {
        if (this._r != n) {
            this._r = n;
            this.updateStyle();
        }
    }
    get g() { return this._g; }
    set g(n) {
        if (this._g != n) {
            this._g = n;
            this.updateStyle();
        }
    }
    get b() { return this._b; }
    set b(n) {
        if (this._b != n) {
            this._b = n;
            this.updateStyle();
        }
    }
    get a() { return this._a; }
    set a(n) {
        if (this._a != n) {
            this._a = n;
            this.updateStyle();
        }
    }
    setRGB(r, g, b) {
        this.useAlpha = false;
        this._r = r;
        this._g = g;
        this._b = b;
        this.updateStyle();
    }
    setRGBA(r, g, b, a) {
        this.useAlpha = true;
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
        this.updateStyle();
    }
    createBrighterColor(pct) {
        var r = this._r + (255 - this._r) * pct;
        var g = this._g + (255 - this._g) * pct;
        var b = this._b + (255 - this._b) * pct;
        return new SolidColor(r, g, b);
    }
    createDarkerColor(pct) {
        var r = this._r * (1 - pct);
        var g = this._g * (1 - pct);
        var b = this._b * (1 - pct);
        return new SolidColor(r, g, b);
    }
    updateStyle(dispatchEvent = true) {
        if (this.useAlpha)
            this._style = "rgba(" + this._r + "," + this._g + "," + this._b + "," + this._a + ")";
        else
            this._style = "rgb(" + this._r + "," + this._g + "," + this._b + ")";
        //console.log(this.style)
        if (dispatchEvent)
            this.dispatchEvent(SolidColor.UPDATE_STYLE);
    }
    get style() { return this._style; }
}
SolidColor.UPDATE_STYLE = "UPDATE_STYLE";
SolidColor.INVISIBLE_COLOR = new SolidColor(0, 0, 0, 0);
//# sourceMappingURL=SolidColor.js.map
class GradientColor extends RegisterableObject {
    constructor(colors = null, ratios = null, isLinear = true) {
        super();
        this.x0 = 0;
        this.y0 = 0;
        this.r0 = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.r1 = 0;
        this.style = null;
        this.ctx = null;
        this.dirty = true;
        this.scaleX = 1;
        this.scaleY = 1;
        this.x = 0; //-> -0.999...+0.999
        this.y = 0; //-> -0.999...+0.999
        this.rotation = 0; // radian
        this.radialFlareX = 0; //-> -0.999...+0.999
        this.radialFlareY = 0; //-> -0.999...+0.999
        this.radialFlareStrength = 1;
        this._scaleX = 1;
        this._scaleY = 1;
        this._x = 0; //-> -0.999...+0.999
        this._y = 0; //-> -0.999...+0.999
        this._rotation = 0; // radian
        this._radialFlareX = 0; //-> -0.999...+0.999
        this._radialFlareY = 0; //-> -0.999...+0.999
        this._radialFlareStrength = 1;
        var th = this;
        //this.onUpdateStyle = function(){th.dirty = true;}
        if (colors)
            this.setColorStep(colors, ratios);
        else {
            this.colors = [];
            this.ratios = [];
        }
        this.isLinear = isLinear;
    }
    get dataString() {
        let i, len = this.colors.length;
        let colors = "", ratios = "";
        for (i = 0; i < len; i++) {
            if (i != 0) {
                colors += ",";
                ratios += ",";
            }
            colors += this.colors[i].REGISTER_ID;
            ratios += this.ratios[i];
        }
        let b = 0;
        if (this.isLinear)
            b = 1;
        return colors + "|" + ratios + "|" + b;
    }
    static fromDataString(data) {
        let t = data.split("|");
        let c = t[0].split(",");
        let r = t[1].split(",");
        let linear = t[2] == "1";
        let i, len = c.length;
        let colors = [];
        let ratios = [];
        for (i = 0; i < len; i++) {
            colors[i] = ObjectLibrary.instance.getObjectByRegisterId(c[i]);
            ratios[i] = Number(r[i]);
        }
        return new GradientColor(colors, ratios, linear);
    }
    clone(cloneColors = false) {
        let c;
        if (cloneColors) {
            c = [];
            let i, len = this.colors.length;
            for (i = 0; i < len; i++)
                c[i] = this.colors[i].clone();
            return new GradientColor(c, this.ratios.concat(), this.isLinear);
        }
        else {
            return new GradientColor(this.colors.concat(), this.ratios.concat(), this.isLinear);
        }
    }
    transformValues(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, flareX = 0, flareY = 0, flareStrength = 0) {
        this._x = x;
        this._y = y;
        this._scaleX = scaleX;
        this._scaleY = scaleY;
        this._rotation = rotation;
        this._radialFlareX = flareX;
        this._radialFlareY = flareY;
        this._radialFlareStrength = flareStrength;
        this.dirty = true;
    }
    initFromPoints(x0, y0, x1, y1, r0 = 0, r1 = 0) {
        this.x0 = x0;
        this.y0 = y0;
        this.r0 = r0;
        this.x1 = x1;
        this.y1 = y1;
        this.r1 = r1;
        this.dirty = true;
    }
    initLinearFromRect(x, y, w, h, angle) {
        const w2 = w / 2;
        const h2 = h / 2;
        const d = Math.sqrt(w2 * w2 + h2 * h2);
        const a1 = angle + Math.PI;
        const a2 = angle;
        x += w2;
        y += h2;
        this.x0 = x + Math.cos(a1) * d;
        this.y0 = y + Math.sin(a1) * d;
        this.x1 = x + Math.cos(a2) * d;
        this.y1 = y + Math.sin(a2) * d;
        this.dirty = true;
    }
    initRadialFromRect(x, y, w, h, radialFlareX = 0, radialFlareY = 0, flareStrength = 1) {
        if (radialFlareX <= -1)
            radialFlareX = -0.999;
        if (radialFlareY <= -1)
            radialFlareY = -0.999;
        if (radialFlareX >= 1)
            radialFlareX = 0.999;
        if (radialFlareY >= 1)
            radialFlareY = 0.999;
        const w2 = w / 2;
        const h2 = h / 2;
        const radius = Math.sqrt(w2 * w2 + h2 * h2);
        x += w2;
        y += h2;
        const a = Math.atan2(radialFlareY, radialFlareX);
        const dx = Math.cos(a) * (radius * radialFlareX);
        const dy = Math.sin(a) * (radius * radialFlareY);
        const d = Math.sqrt(dx * dx + dy * dy);
        this.x0 = x + Math.cos(a) * d;
        this.x1 = x;
        this.y0 = y + Math.sin(a) * d;
        this.y1 = y;
        this.r0 = 0;
        this.r1 = radius * flareStrength;
        this.dirty = true;
    }
    setColorStep(colors, ratios = null) {
        let i, nbStep, ratio, n;
        if (colors.length > 1) {
            if (ratios && colors.length <= ratios.length) {
                this.ratios = ratios;
                this.nbStep = colors.length;
                this.colors = colors;
            }
            else {
                this.nbStep = nbStep = colors.length;
                ratio = 0;
                n = 1 / (nbStep - 1);
                this.ratios = [];
                for (i = 0; i < nbStep; i++) {
                    this.ratios[i] = ratio;
                    ratio += n;
                }
            }
        }
        else {
            colors.push(colors[0]);
            this.nbStep = 2;
            this.ratios = [0, 1];
        }
        nbStep = this.nbStep;
        for (i = 0; i < nbStep; i++) {
            if (this.colors && this.colors[i])
                this.colors[i].removeEventListener(SolidColor.UPDATE_STYLE, this.onUpdateStyle);
            colors[i].addEventListener(SolidColor.UPDATE_STYLE, this.onUpdateStyle);
        }
        this.colors = colors;
        this.dirty = true;
    }
    addColorStep(ratio, r = 0, g = 0, b = 0, a = 1) {
        //var step:GradientStep = new GradientStep(this,ratio,r,g,b,a);
        var color = this.colors[this.nbStep] = new SolidColor(r, g, b, a);
        this.ratios[this.nbStep++] = ratio;
        return color;
    }
    getColorById(id) { return this.colors[id]; }
    setColorById(id, color) {
        if (this.colors[id]) {
            this.colors[id].removeEventListener(SolidColor.UPDATE_STYLE, this.onUpdateStyle);
            this.colors[id] = color;
            color.addEventListener(SolidColor.UPDATE_STYLE, this.onUpdateStyle);
        }
    }
    getRatioById(id) { return this.ratios[id]; }
    setRatioById(id, ratio) {
        this.ratios[id] = ratio;
    }
    getGradientStyle(context2D, target) {
        let obj;
        if (this.dirty || this.ctx != context2D) {
            this.ctx = context2D;
            const x = this.x + this._x;
            const y = this.y + this._y;
            const scaleX = this.scaleX * this._scaleX;
            const scaleY = this.scaleY * this._scaleY;
            const rotation = this.rotation + this._rotation;
            const flareX = this.radialFlareX * this._radialFlareX;
            const flareY = this.radialFlareY * this._radialFlareY;
            const flareStrength = this.radialFlareStrength * this._radialFlareStrength;
            if (this.isLinear) {
                this.initLinearFromRect(x, y, scaleX, scaleY, rotation);
                obj = context2D.createLinearGradient(this.x0, this.y0, this.x1, this.y1);
            }
            else {
                this.initRadialFromRect(x, y, scaleX, scaleY, flareX, flareY, flareStrength);
                obj = context2D.createRadialGradient(this.x0, this.y0, this.r0, this.x1, this.y1, this.r1);
            }
            let i, nb = this.nbStep;
            const ratios = this.ratios;
            const colors = this.colors;
            for (i = 0; i < nb; i++)
                obj.addColorStop(ratios[i], colors[i].style);
            this.style = obj;
            this.dirty = false;
        }
        return this.style;
    }
}
//# sourceMappingURL=GradientColor.js.map
class ShadowFilter {
    constructor(solidColor, blur, offsetX, offsetY) {
        this.solidColor = solidColor;
        this.blur = blur;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    }
    apply(context2D) {
        context2D.shadowColor = this.solidColor.style;
        context2D.shadowBlur = this.blur;
        context2D.shadowOffsetX = this.offsetX;
        context2D.shadowOffsetY = this.offsetY;
    }
}
ShadowFilter.NO_SHADOW = new ShadowFilter(SolidColor.INVISIBLE_COLOR, 0, 0, 0);
//# sourceMappingURL=ShadowFilter.js.map
class GlobalCompositeOperation {
}
GlobalCompositeOperation.DEFAULT = "source-over";
GlobalCompositeOperation.SOURCE_OVER = "source-over";
GlobalCompositeOperation.SOURCE_IN = "source-in";
GlobalCompositeOperation.SOURCE_OUT = "source-out";
GlobalCompositeOperation.SOURCE_ATOP = "source-atop";
GlobalCompositeOperation.DESTINATION_OVER = "destination-over";
GlobalCompositeOperation.DESTINATION_IN = "destination-in";
GlobalCompositeOperation.DESTINATION_OUT = "destination-out";
GlobalCompositeOperation.DESTINATION_ATOP = "destination-atop";
GlobalCompositeOperation.LIGHTER = "lighter";
GlobalCompositeOperation.LIGHTEN = "lighten";
GlobalCompositeOperation.OVERLAY = "overlay";
GlobalCompositeOperation.DARKEN = "darken";
GlobalCompositeOperation.HARD_LIGHT = "hard-light";
GlobalCompositeOperation.SOFT_LIGHT = "soft-light";
GlobalCompositeOperation.COPY = "copy";
GlobalCompositeOperation.XOR = "xor";
GlobalCompositeOperation.MULTIPLY = "mutiply";
GlobalCompositeOperation.SCREEN = "screen";
GlobalCompositeOperation.COLOR_DODGE = "color-dodge";
GlobalCompositeOperation.COLOR_BURN = "color-burn";
GlobalCompositeOperation.DIFFERENCE = "difference";
GlobalCompositeOperation.EXCLUSION = "exclusion";
GlobalCompositeOperation.HUE = "hue";
GlobalCompositeOperation.SATURATION = "saturation";
GlobalCompositeOperation.COLOR = "color";
GlobalCompositeOperation.LUMINOSITY = "luminosity";
GlobalCompositeOperation.MASK_OUTSIDE = GlobalCompositeOperation.SOURCE_ATOP;
GlobalCompositeOperation.MASK_INSIDE = GlobalCompositeOperation.XOR;
//# sourceMappingURL=GlobalCompositeOperation.js.map
class BorderPt extends Pt2D {
    
    constructor(x, y, id) {
        super(x, y);
        this.id = id;
    }
    clone() {
        return new BorderPt(this.x, this.y, this.id);
    }
    distanceTo(pt) {
        var dx = pt.x - this.x;
        var dy = pt.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    distance(px, py) {
        var dx = px - this.x;
        var dy = py - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    angleTo(pt) {
        var dx = pt.x - this.x;
        var dy = pt.y - this.y;
        return Math.atan2(dy, dx);
    }
}
//# sourceMappingURL=BorderPt.js.map

class BorderLine {
    constructor(p0, p1) {
        this.dist = 9999999999;
        this.color = "#ff0000";
        this.actif = true;
        this.start = p0;
        this.end = p1;
        this.points = [p0, p1];
    }
    addPointToStart(pt) {
        this.start = pt;
        this.points.unshift(pt);
    }
    addPointToEnd(pt) {
        this.end = pt;
        this.points.push(pt);
    }
    findNearestPoint(px, py) {
        var i, len = this.points.length;
        var dx, dy;
        var pt;
        for (i = 0; i < len; i++) {
            pt = this.points[i];
            dx = pt.x - px;
            dy = pt.y - py;
            pt.dist = Math.sqrt(dx * dx + dy * dy);
        }
        var v = this.points.concat();
        v.sort(function (p0, p1) {
            if (p0.dist < p1.dist)
                return -1;
            else
                return 1;
        });
        i = 0;
        while (v[i].isQuadPoint && i < v.length - 1)
            i++;
        v[i].isQuadPoint = true;
        return v[i];
    }
    draw(ctx, offsetX = 0, offsetY = 0) {
        ctx.strokeStyle = this.color;
        ctx.moveTo(offsetX + this.points[0].x, offsetY + this.points[0].y);
        var i, len = this.points.length;
        for (i = 1; i < len; i++)
            ctx.lineTo(offsetX + this.points[i].x, offsetY + this.points[i].y);
        ctx.stroke();
    }
    getDistanceFromPoint(px, py) {
        var d = 1000000;
        var n;
        var points = this.points;
        var i, len = points.length;
        for (i = 1; i < len; i++) {
            n = this.distanceFromPointToLine(px, py, points[i - 1].x, points[i].x, points[i - 1].y, points[i].y);
            if (n < d)
                d = n;
        }
        this.dist = d;
        return this.dist;
    }
    distanceFromPointToLine(x, y, x1, x2, y1, y2) {
        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;
        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = -1;
        if (len_sq != 0) { //in case of 0 length line
            param = dot / len_sq;
        }
        var xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        var dx = x - xx;
        var dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }
    orientationIsCorrect(p0, p1, a) {
        var angle = p0.angleTo(p1);
        var da = angle - a;
        if (da > Math.PI)
            angle -= Math.PI * 2;
        else if (da < -Math.PI)
            a -= Math.PI * 2;
        da = Math.abs(angle - a);
        a += Math.PI;
        var da2 = angle - a;
        if (da2 > Math.PI)
            angle -= Math.PI * 2;
        else if (da2 < -Math.PI)
            a -= Math.PI * 2;
        da2 = Math.abs(angle - a);
        return (da < 0.1 || da2 < 0.1);
    }
    lookForNearLines(lines, a) {
        if (a == 0 || a == Math.PI)
            this.color = "#ff0000";
        else
            this.color = "#00ff00";
        if (this.actif == false)
            return;
        var i, len;
        var working = true;
        var currentLine;
        var minDist = 10;
        var pt;
        var angle;
        var j, len2;
        while (working) {
            working = false;
            len = lines.length;
            for (i = 0; i < len; i++) {
                currentLine = lines[i];
                if (currentLine == this || currentLine.actif == false)
                    continue;
                pt = currentLine.start;
                if (this.start.distanceTo(pt) < minDist && this.orientationIsCorrect(pt, this.start, a)) {
                    len2 = currentLine.points.length;
                    for (j = 0; j < len2; j++)
                        this.addPointToStart(currentLine.points[j]);
                    currentLine.actif = false;
                    currentLine.points = null;
                    currentLine.start = currentLine.end = null;
                    working = true;
                    break;
                }
                pt = currentLine.end;
                if (this.start.distanceTo(pt) < minDist && this.orientationIsCorrect(pt, this.start, a)) {
                    len2 = currentLine.points.length - 1;
                    for (j = len2; j > -1; j--)
                        this.addPointToStart(currentLine.points[j]);
                    currentLine.actif = false;
                    currentLine.points = null;
                    currentLine.start = currentLine.end = null;
                    working = true;
                    break;
                }
                pt = currentLine.start;
                if (this.end.distanceTo(pt) < minDist && this.orientationIsCorrect(this.end, pt, a)) {
                    len2 = currentLine.points.length;
                    for (j = 0; j < len2; j++)
                        this.addPointToEnd(currentLine.points[j]);
                    currentLine.actif = false;
                    currentLine.points = null;
                    currentLine.start = currentLine.end = null;
                    working = true;
                    break;
                }
                pt = currentLine.end;
                if (this.end.distanceTo(pt) < minDist && this.orientationIsCorrect(this.end, pt, a)) {
                    len2 = currentLine.points.length - 1;
                    for (j = len2; j > -1; j--)
                        this.addPointToEnd(currentLine.points[j]);
                    currentLine.actif = false;
                    currentLine.points = null;
                    currentLine.start = currentLine.end = null;
                    working = true;
                    break;
                }
            }
        }
    }
}
//# sourceMappingURL=BorderLine.js.map
class BorderFinder {
    constructor() {
        this.directions = "";
        this.radian = Math.PI / 180;
        this.secondPass = false;
        this.bugScale = 1.25;
        //if(BorderFinder._instance){
        //  throw new Error("BorderFinder is a singleton. You must use BorderFinder.instance .");
        //}
        BorderFinder._instance = this;
        this.diago = Math.sqrt(2);
        var directionDatas = [];
        for (var i = 0; i < 766; i++)
            directionDatas[i] = 0;
        directionDatas[0] = 3;
        directionDatas[45] = 4;
        directionDatas[90] = 5;
        directionDatas[135] = 6;
        directionDatas[180] = 7;
        directionDatas[225] = 8;
        directionDatas[270] = 1;
        directionDatas[315] = 2;
        directionDatas[360] = 3;
        directionDatas[405] = 4;
        directionDatas[450] = 5;
        directionDatas[495] = 6;
        directionDatas[540] = 7;
        directionDatas[585] = 8;
        directionDatas[630] = 1;
        directionDatas[675] = 2;
        directionDatas[720] = 3;
        directionDatas[765] = 4;
        BorderFinder.directionDatas = directionDatas;
        var offsetX = BorderFinder.offsetX = [];
        var offsetY = BorderFinder.offsetY = [];
        offsetX[0] = 1;
        offsetY[0] = -1;
        offsetX[45] = 1;
        offsetY[45] = 0;
        offsetX[90] = 1;
        offsetY[90] = 1;
        offsetX[135] = 0;
        offsetY[135] = 1;
        offsetX[180] = -1;
        offsetY[180] = 1;
        offsetX[225] = -1;
        offsetY[225] = 0;
        offsetX[270] = -1;
        offsetY[270] = -1;
        offsetX[315] = 0;
        offsetY[315] = -1;
        offsetX[360] = 1;
        offsetY[360] = -1;
        offsetX[405] = 1;
        offsetY[405] = 0;
        offsetX[450] = 1;
        offsetY[450] = 1;
        offsetX[495] = 0;
        offsetY[495] = 1;
        offsetX[540] = -1;
        offsetY[540] = 1;
        offsetX[585] = -1;
        offsetY[585] = 0;
        offsetX[630] = -1;
        offsetY[630] = -1;
        offsetX[675] = 0;
        offsetY[675] = -1;
        offsetX[720] = 1;
        offsetY[720] = -1;
        offsetX[765] = 1;
        offsetY[765] = 0;
    }
    reset() {
        this.directionDatas = [];
        this.borderPoints = null;
        this.directions = "";
        this.bd = null;
        this.center = null;
        this.pt = null;
        this.first = null;
        this.diago = null;
        this.n = null;
        this.tab = null;
        this.old = null;
        this.count = null;
        this.working = null;
        this.oldAngle = null;
        this.firstId = null;
        this.offsetX = null;
        this.offsetY = null;
        this._width = null;
        this._height = null;
        this.bug = null;
        this.usedImg = null;
        this.pixelUsed = null;
        this.sourceBd = null;
        this.matrix = null;
        this.outColor = null;
        this.colorTracking = null;
        this.trackCol = null;
        this.offsetAngle = null;
        this.secondPass = null;
        this.holeBd = null;
        this.minX = null;
        this.minY = null;
        this.maxX = null;
        this.maxY = null;
        this.scaleRatio = null;
        this.bugScale = 1.25;
    }
    static get instance() {
        if (!BorderFinder._instance)
            new BorderFinder();
        return BorderFinder._instance;
    }
    ;
    get holePicture() { return this.holeBd; }
    getOutsideBorder(source) {
        var r = source.getAlphaChannelBoundRect(0, 0, source.width, source.height, 0, 0);
        var _temp = new BitmapData(r.w, r.h, "rgba(0,0,0,0)", true);
        //matrix.identity();
        //matrix.translate(-r.x, -r.y);
        //_temp.draw(source, matrix);
        _temp.drawImage(source.htmlCanvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);
        var res = this.getBorderFromBitmapData(_temp, false);
        if (res) {
            let i, len = res.length;
            for (i = 0; i < len; i++) {
                res[i].x += r.x;
                res[i].y += r.y;
            }
        }
        return res;
    }
    createGraphicsGeometryFromBitmapData(source, firstPassPrecision = 0.2, fitCurvePrecision = 1) {
        var geom = new GraphicGeometry();
        var border = this.getBorderFromBitmapData(source);
        var vectoBorder = BorderVectorizer.instance.init((border.length * firstPassPrecision) >> 0, border);
        var curves = FitCurve.borderToCurve(vectoBorder, fitCurvePrecision);
        var i, len = curves.length;
        var bezier;
        for (i = 0; i < len; i++) {
            bezier = curves[i];
            if (i == 0)
                geom.moveTo(bezier[0][0], bezier[0][1]);
            geom.bezierCurveTo(bezier[1][0], bezier[1][1], bezier[2][0], bezier[2][1], bezier[3][0], bezier[3][1]);
        }
        return geom;
    }
    getBorderFromBitmapData(source, trackColor = false, colorTracked = { r: 255, g: 0, b: 255, a: 0 }, areaRect = null, secondPass = false, borderX = 0, borderY = 0) {
        //if(source != sourceBd) secondPass = false;
        this.reset();
        this.directions = "";
        let tab = this.tab = [];
        let n = this.n = 0;
        let old = this.old = new BorderPt(0, 0, 0);
        let count = this.count = 0;
        let directionDatas = BorderFinder.directionDatas;
        var offsetX = this.offsetX = BorderFinder.offsetX;
        var offsetY = this.offsetY = BorderFinder.offsetY;
        let colorTracking = this.colorTracking = trackColor;
        let trackCol = this.trackCol = colorTracked;
        let minX, minY, maxX, maxY;
        minX = minY = 99999999;
        maxX = maxY = 0;
        this.sourceBd = source;
        var area = source.width * source.height;
        if (areaRect)
            area = areaRect.w * areaRect.h;
        var s = (300 * 300) / area;
        if (s < 1)
            s = 1;
        else if (s > 2)
            s = 2;
        //console.log("getBorder scale = ",s, (400*400),area)
        if (secondPass)
            s += 1;
        let scaleRatio = this.scaleRatio = s;
        var pw2 = (source.width * s) >> 0; //(val >> 0) = int(val);
        var ph2 = (source.height * s) >> 0;
        if (!this.bd)
            this.bd = new BitmapData(pw2 + 4, ph2 + 4, "rgba(0,0,0,0)", true);
        else
            this.bd.resize(pw2 + 4, ph2 + 4);
        let bd = this.bd;
        bd.drawImage(source.htmlCanvas, 0, 0, source.width, source.height, 2, 2, pw2, ph2);
        this.pixelUsed = [];
        let pixelUsed = this.pixelUsed;
        var i, len = bd.width * bd.height;
        for (i = 0; i < len; i++)
            pixelUsed[i] = false;
        var px = bd.width >> 1;
        var py = 2;
        var r;
        var j;
        if (colorTracking == false) {
            r = bd.getAlphaChannelBoundRect(0, 0, bd.width, bd.height, 0, 0);
            len = r.w + 1;
            px = r.x - 1;
            py = (r.y + r.w / 2) >> 0;
            for (i = 0; i < r.w; i++) {
                if (0 == bd.getPixelAlpha(px, py))
                    px++;
                else
                    break;
            }
        }
        else {
            r = bd.getColorBoundRect(0, 0, bd.width, bd.height, trackCol.r, trackCol.g, trackCol.b, trackCol.a);
            len = r.w + 1;
            px = r.x;
            py = r.y;
            for (i = 0; i < len; i++) {
                if (!bd.matchColor(px, py, trackCol.r, trackCol.g, trackCol.b, trackCol.a))
                    px++;
                else
                    break;
            }
        }
        n = 0;
        tab = this.tab = [];
        old = this.old = new BorderPt(0, 0, 0);
        let directions = this.directions = "";
        this.count = 0;
        this.first = this.center = new BorderPt(px, py, 0);
        let pt = this.pt = new BorderPt(px - 1, py, 0);
        let firstId;
        let id = firstId = this.firstId = (py * bd.width + px) >> 0; //(val) >> 0 = int(val)
        pixelUsed[id] = true;
        this._width = bd.width;
        this._height = bd.height;
        this.bug = false;
        this.offsetAngle = 0;
        this.working = true;
        if (colorTracking == false) {
            while (this.working && this.bug == false) {
                this.getBorder();
                this.bug = this.count > 100;
            }
        }
        else {
            while (this.working && this.bug == false) {
                this.getBorderColorTracking();
                this.bug = this.count > 100;
            }
        }
        this.borderPoints = null;
        if (this.bug == true) {
            if (secondPass == true || colorTracking) {
                //console.log("borderFinder second pass bug found");
                return null;
            }
            //console.log("bug found");
            var temp = source.clone();
            temp.applyFilter("blur(0.05px)");
            return this.getBorderFromBitmapData(temp, colorTracking, trackCol, areaRect, true);
        }
        //if (secondPass) s *= bugScale;
        len = tab.length;
        var prev = tab[tab.length - 1];
        for (i = 0; i < len; i++) {
            pt = tab[i];
            pt.x = (borderX + (pt.x) / s) >> 0; //(val >> 0) = int(val)
            pt.y = (borderY + (pt.y) / s) >> 0;
            pt.id = i;
            pt.prev = prev;
            prev.next = pt;
            prev = pt;
        }
        this.borderPoints = tab;
        return tab;
    }
    returnAngle(p0, p1) {
        return (Math.atan2(p1.y - p0.y, p1.x - p0.x) / (Math.PI / 180.0)) >> 0; //(val >> 0) = int(val)
    }
    getBorder() {
        let _angle = this.returnAngle(this.center, this.pt) + 45;
        let a = _angle;
        let test = a - this.oldAngle > 0;
        let len = a + 315;
        let r;
        let px = 0, py = 0;
        let temp;
        let bool = false;
        let pixelIndex;
        let radian = this.radian;
        let center = this.center;
        let pixelUsed = this.pixelUsed;
        let diago = this.diago;
        let _width = this._width;
        let bd = this.bd;
        let directionDatas = this.directionDatas;
        let firstId = this.firstId;
        let tab = this.tab;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        while (a < len) {
            
            px = center.x + offsetX[a + 135];
            py = center.y + offsetY[a + 135];
            pixelIndex = py * _width + px;
            //console.log(py,_width,px)
            if (0 != bd.getPixelAlpha(px, py)) {
                if (true == pixelUsed[pixelIndex]) {
                    if (pixelIndex == firstId) {
                        //console.log("FINISH");
                        //trace("len = " + tab.length);
                        bool = false;
                        this.working = false;
                        this.count = 0;
                        break;
                    }
                }
                else {
                    if (!pixelUsed[pixelIndex]) {
                        this.directions += directionDatas[a + 45];
                        pixelUsed[pixelIndex] = true;
                        tab.push(new BorderPt(px, py, this.n++)); //new Point(px, py);
                        bool = true;
                        break;
                    }
                }
            }
            a += 45;
        }
        if (bool) {
            temp = new BorderPt(center.x, center.y, 0);
            this.center = new BorderPt(px, py, 0);
            this.pt = new BorderPt(temp.x, temp.y, 0);
            this.count = 0;
        }
        else {
            center = new BorderPt(this.pt.x, this.pt.y, 0);
            this.count++;
            //console.log(this.count)
            var d = tab.length - this.count;
            if (d >= 0)
                this.pt = tab[d];
            else {
                //console.log("work = false")
                this.working = false;
            }
        }
    }
    getBorderColorTracking() {
        let _angle = this.returnAngle(this.center, this.pt) + 45;
        let a = _angle;
        let test = a - this.oldAngle > 0;
        let len = a + 450;
        let r;
        let px = 0, py = 0;
        let temp;
        let bool = false;
        let pixelIndex;
        let radian = this.radian;
        let center = this.center;
        let pixelUsed = this.pixelUsed;
        let diago = this.diago;
        let _width = this._width;
        let bd = this.bd;
        let directionDatas = this.directionDatas;
        let firstId = this.firstId;
        let tab = this.tab;
        let red = this.trackCol.r;
        let green = this.trackCol.g;
        let blue = this.trackCol.b;
        let alpha = this.trackCol.a;
        while (a < len) {
            r = radian * a;
            
            if (a % 45 != 0) {
                px = (center.x + Math.cos(r) * diago) >> 0;
                py = (center.y + Math.sin(r) * diago) >> 0;
            }
            else {
                px = (center.x + Math.cos(r)) >> 0;
                py = (center.y + Math.sin(r)) >> 0;
            }
            pixelIndex = py * _width + px;
            if (bd.matchColor(px, py, red, green, blue, alpha)) {
                if (true == pixelUsed[pixelIndex]) {
                    if (pixelIndex == firstId) {
                        //console.log("FINISH");
                        //trace("len = " + tab.length);
                        bool = false;
                        this.working = false;
                        this.count = 0;
                        break;
                    }
                }
                else {
                    if (!pixelUsed[pixelIndex]) {
                        this.directions += directionDatas[a + 45];
                        pixelUsed[pixelIndex] = true;
                        tab.push(new BorderPt(px, py, this.n++)); //new Point(px, py);
                        bool = true;
                        break;
                    }
                }
            }
            a += 45;
        }
        if (bool) {
            temp = new BorderPt(center.x, center.y, 0);
            this.center = new BorderPt(px, py, 0);
            this.pt = new BorderPt(temp.x, temp.y, 0);
            this.count = 0;
        }
        else {
            center = new BorderPt(this.pt.x, this.pt.y, 0);
            this.count++;
            //console.log(this.count)
            var d = tab.length - this.count;
            if (d >= 0)
                this.pt = tab[d];
            else {
                //console.log("work = false")
                this.working = false;
            }
        }
    }
    getNumberOfHoles(source) {
        var picture = source.clone();
        var r = picture.getAlphaChannelBoundRect(0, 0, picture.width, picture.height, 0, 0);
        var i, len;
        var floodColor = { r: 100, g: 0, b: 255, a: 255 }; //xff00ff00;
        var count = 0;
        var sw = source.width;
        var sh = source.height;
        while (r != null && r.w != 0 && r.h != 0) {
            len = r.w;
            for (i = 0; i < len; i++) {
                //if (!picture.isOpaque(r.x + i, r.y)) {
                if (picture.matchAlpha(r.x + i, r.y, 0)) {
                    //console.log(i," picture.floodFillRGBA(",r.x + i, r.y, floodColor.r,floodColor.g,floodColor.b,floodColor.a)
                    var bounds = picture.floodFillRGBA(r.x + i, r.y, floodColor.r, floodColor.g, floodColor.b, floodColor.a).bounds;
                    //r = picture.getColorBoundRect(0,0,picture.width,picture.height,floodColor.r,floodColor.g,floodColor.b,floodColor.a);
                    floodColor.g = (Math.random() * 255) >> 0;
                    floodColor.b = (Math.random() * 255) >> 0;
                    floodColor.r = (Math.random() * 255) >> 0;
                    if (bounds.x > 0 && bounds.y > 0 && bounds.x + bounds.width < sw && bounds.y + bounds.height < sh)
                        count++;
                    break;
                }
            }
            r = picture.getAlphaChannelBoundRect(0, 0, picture.width, picture.height, 0, 0);
        }
        console.log("nbHole = ", count);
        return count;
    }
    getHoleBorders(source) {
        //first Part :
        //1) find a region containing alpha pixels
        //2) fill that region with a color in another canvas and keep its boundary
        //3) extract the region in another canvas at the good dimension
        var result = [];
        var picture = source; //.clone();
        var r = picture.getAlphaChannelBoundRect(0, 0, picture.width, picture.height, 0, 0);
        var i, len;
        var floodColor = { r: 255, g: 0, b: 255, a: 255 }; //xff00ff00;
        floodColor.g = (Math.random() * 255) >> 0;
        floodColor.b = (Math.random() * 255) >> 0;
        floodColor.r = (Math.random() * 255) >> 0;
        var count = 0;
        var sw = source.width;
        var sh = source.height;
        var area = { x: 0, y: 0, w: source.width, h: source.height };
        var holeBd;
        while (r != null && r.w != 0 && r.h != 0) {
            len = r.w;
            for (i = 0; i < len; i++) {
                if (picture.matchAlpha(r.x + i, r.y, 0)) {
                    holeBd = picture.floodFillRGBAandReturnOutputCanvas(r.x + i, r.y, floodColor.r, floodColor.g, floodColor.b, floodColor.a);
                    //document.body.appendChild(holeBd.htmlCanvas)
                    if (holeBd.offsetX > 0 && holeBd.offsetY > 0 && holeBd.offsetX + holeBd.width < sw - 1 && holeBd.offsetY + holeBd.height < sh - 1) { //if its not an outside border
                        result[count++] = holeBd;
                    }
                    floodColor.g = (Math.random() * 255) >> 0;
                    floodColor.b = (Math.random() * 255) >> 0;
                    floodColor.r = (Math.random() * 255) >> 0;
                    break;
                }
            }
            r = picture.getAlphaChannelBoundRect(0, 0, picture.width, picture.height, 0, 0);
        }
        //second part :
        //for each rect-bounds & color , figure out the border
        var i;
        var borders = [];
        var offX = [];
        var offY = [];
        for (i = 0; i < result.length; i++) {
            holeBd = result[i];
            offX[i] = holeBd.offsetX;
            offY[i] = holeBd.offsetY;
            borders[i] = this.getBorderFromBitmapData(holeBd, false, { r: 0, g: 0, b: 0, a: 0 }, null, false, holeBd.offsetX, holeBd.offsetY);
            //this.debugBorder(holeBd.context,borders[i]);
            //document.body.appendChild(holeBd.htmlCanvas)
            //console.log(i+" | "+area.w+" , "+area.h+" =>> ",borders[i].length);
        }
        return borders; //{borders:borders,borderX:offX,borderY:offY}
    }
    debugBorder(ctx, border, strokeStyle = "#000000", b = true, px = 0, py = 0) {
        ctx.strokeStyle = ctx.fillStyle = strokeStyle;
        ctx.beginPath();
        ctx.moveTo(border[0].x + px, border[0].y + py);
        if (b)
            for (var i = 1; i < border.length; i++)
                ctx.lineTo(border[i].x + px, border[i].y + py);
        else
            for (var i = border.length - 1; i >= 0; i--)
                ctx.lineTo(border[i].x + px, border[i].y + py);
        ctx.stroke();
        // ctx.fill()
    }
}
//# sourceMappingURL=BorderFinder.js.map

class BorderLinePt {
    constructor() {
    }
    reset() {
        this.p1 = this.p2 = null;
        this.id = this.d = this.a = this.x = this.y = 0;
    }
}
//# sourceMappingURL=BorderLinePt.js.map
class FitCurve {
    constructor() {
    }
    static borderToCurve(border, maxError = 10, progressCallback = null) {
        var points = [];
        var i, len = border.length;
        for (i = 0; i < len; i++) {
            points[i] = [border[i].x, border[i].y];
        }
        return this.fitCurve(points, maxError, progressCallback);
    }
    static drawCurves(ctx, curves) {
        ctx.strokeStyle = "#ff0000";
        ctx.beginPath();
        var i, len = curves.length;
        var curve;
        for (i = 0; i < len; i++) {
            curve = curves[i];
            ctx.moveTo(curve[0][0], curve[0][1]);
            ctx.bezierCurveTo(curve[1][0], curve[1][1], curve[2][0], curve[2][1], curve[3][0], curve[3][1]);
        }
        ctx.stroke();
    }
    static fitCurve(points, maxError = 5, progressCallback = null) {
        if (!Array.isArray(points)) {
            throw new TypeError("First argument should be an array");
        }
        points.forEach((point) => {
            if (!Array.isArray(point) || point.length !== 2
                || typeof point[0] !== 'number' || typeof point[1] !== 'number') {
                throw Error("Each point should be an array of two numbers");
            }
        });
        // Remove duplicate points
        points = points.filter((point, i) => i === 0 || !(point[0] === points[i - 1][0] && point[1] === points[i - 1][1]));
        if (points.length < 2) {
            return [];
        }
        const len = points.length;
        const leftTangent = this.createTangent(points[1], points[0]);
        const rightTangent = this.createTangent(points[len - 2], points[len - 1]);
        return this.fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
    }
    static fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
        const MaxIterations = 20; //Max times to try iterating (to find an acceptable curve)
        var bezCurve, //Control points of fitted Bezier curve
        u, //Parameter values for point
        uPrime, //Improved parameter values
        maxError, prevErr, //Maximum fitting error
        splitPoint, prevSplit, //Point to split point set at if we need more than one curve
        centerVector, toCenterTangent, fromCenterTangent, //Unit tangent vector(s) at splitPoint
        beziers, //Array of fitted Bezier curves if we need more than one curve
        dist, i;
        //console.log('fitCubic, ', points.length);
        //Use heuristic if region only has two points in it
        if (points.length === 2) {
            dist = this.vectorLen(this.subtract(points[0], points[1])) / 3.0;
            bezCurve = [
                points[0],
                this.addArrays(points[0], this.mulItems(leftTangent, dist)),
                this.addArrays(points[1], this.mulItems(rightTangent, dist)),
                points[1]
            ];
            return [bezCurve];
        }
        //Parameterize points, and attempt to fit curve
        u = this.chordLengthParameterize(points);
        [bezCurve, maxError, splitPoint] = this.generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
        if (maxError < error) {
            return [bezCurve];
        }
        //If error not too large, try some reparameterization and iteration
        if (maxError < (error * error)) {
            uPrime = u;
            prevErr = maxError;
            prevSplit = splitPoint;
            for (i = 0; i < MaxIterations; i++) {
                uPrime = this.reparameterize(bezCurve, points, uPrime);
                [bezCurve, maxError, splitPoint] = this.generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
                if (maxError < error) {
                    return [bezCurve];
                }
                //If the development of the fitted curve grinds to a halt,
                //we abort this attempt (and try a shorter curve):
                else if (splitPoint === prevSplit) {
                    let errChange = maxError / prevErr;
                    if ((errChange > .9999) && (errChange < 1.0001)) {
                        break;
                    }
                }
                prevErr = maxError;
                prevSplit = splitPoint;
            }
        }
        //Fitting failed -- split at max error point and fit recursively
        beziers = [];
        //To create a smooth transition from one curve segment to the next, we
        //calculate the line between the points directly before and after the
        //center, and use that as the tangent both to and from the center point.
        centerVector = this.subtract(points[splitPoint - 1], points[splitPoint + 1]);
        //However, this won't work if they're the same point, because the line we
        //want to use as a tangent would be 0. Instead, we calculate the line from
        //that "double-point" to the center point, and use its tangent.
        if ((centerVector[0] === 0) && (centerVector[1] === 0)) {
            //[x,y] -> [-y,x]: http://stackoverflow.com/a/4780141/1869660
            centerVector = this.subtract(points[splitPoint - 1], points[splitPoint]);
            [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
        }
        toCenterTangent = this.normalize(centerVector);
        //To and from need to point in opposite directions:
        fromCenterTangent = this.mulItems(toCenterTangent, -1);
        
        beziers = beziers.concat(this.fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
        beziers = beziers.concat(this.fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
        return beziers;
    }
    static generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
        var bezCurve, maxError, splitPoint;
        bezCurve = this.generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
        //Find max deviation of points to fitted curve.
        //Here we always use the original parameters (from chordLengthParameterize()),
        //because we need to compare the current curve to the actual source polyline,
        //and not the currently iterated parameters which reparameterize() & generateBezier() use,
        //as those have probably drifted far away and may no longer be in ascending order.
        [maxError, splitPoint] = this.computeMaxError(points, bezCurve, paramsOrig);
        if (progressCallback) {
            progressCallback({
                bez: bezCurve,
                points: points,
                params: paramsOrig,
                maxErr: maxError,
                maxPoint: splitPoint,
            });
        }
        return [bezCurve, maxError, splitPoint];
    }
    static generateBezier(points, parameters, leftTangent, rightTangent, progressCallback) {
        var bezCurve, //Bezier curve ctl pts
        A, a, //Precomputed rhs for eqn
        C, X, //Matrices C & X
        det_C0_C1, det_C0_X, det_X_C1, //Determinants of matrices
        alpha_l, alpha_r, //Alpha values, left and right
        epsilon, segLength, i, len, tmp, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
        bezCurve = [firstPoint, null, null, lastPoint];
        //console.log('gb', parameters.length);
        //Compute the A's
        A = this.zeros_Xx2x2(parameters.length);
        for (i = 0, len = parameters.length; i < len; i++) {
            u = parameters[i];
            ux = 1 - u;
            a = A[i];
            a[0] = this.mulItems(leftTangent, 3 * u * (ux * ux));
            a[1] = this.mulItems(rightTangent, 3 * ux * (u * u));
        }
        //Create the C and X matrices
        C = [[0, 0], [0, 0]];
        X = [0, 0];
        for (i = 0, len = points.length; i < len; i++) {
            u = parameters[i];
            a = A[i];
            C[0][0] += this.dot(a[0], a[0]);
            C[0][1] += this.dot(a[0], a[1]);
            C[1][0] += this.dot(a[0], a[1]);
            C[1][1] += this.dot(a[1], a[1]);
            tmp = this.subtract(points[i], this.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
            X[0] += this.dot(a[0], tmp);
            X[1] += this.dot(a[1], tmp);
        }
        //Compute the determinants of C and X
        det_C0_C1 = (C[0][0] * C[1][1]) - (C[1][0] * C[0][1]);
        det_C0_X = (C[0][0] * X[1]) - (C[1][0] * X[0]);
        det_X_C1 = (X[0] * C[1][1]) - (X[1] * C[0][1]);
        //Finally, derive alpha values
        alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
        alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
        //If alpha negative, use the Wu/Barsky heuristic (see text).
        //If alpha is 0, you get coincident control points that lead to
        //divide by zero in any subsequent NewtonRaphsonRootFind() call.
        segLength = this.vectorLen(this.subtract(firstPoint, lastPoint));
        epsilon = 1.0e-6 * segLength;
        if (alpha_l < epsilon || alpha_r < epsilon) {
            //Fall back on standard (probably inaccurate) formula, and subdivide further if needed.
            bezCurve[1] = this.addArrays(firstPoint, this.mulItems(leftTangent, segLength / 3.0));
            bezCurve[2] = this.addArrays(lastPoint, this.mulItems(rightTangent, segLength / 3.0));
        }
        else {
            //First and last control points of the Bezier curve are
            //positioned exactly at the first and last data points
            //Control points 1 and 2 are positioned an alpha distance out
            //on the tangent vectors, left and right, respectively
            bezCurve[1] = this.addArrays(firstPoint, this.mulItems(leftTangent, alpha_l));
            bezCurve[2] = this.addArrays(lastPoint, this.mulItems(rightTangent, alpha_r));
        }
        return bezCurve;
    }
    static reparameterize(bezier, points, parameters) {
        
        return parameters.map((p, i) => this.newtonRaphsonRootFind(bezier, points[i], p));
    }
    ;
    static newtonRaphsonRootFind(bez, point, u) {
        
        var d = this.subtract(this.q(bez, u), point), qprime = this.qprime(bez, u), numerator = this.mulMatrix(d, qprime), denominator = this.sum(this.squareItems(qprime)) + 2 * this.mulMatrix(d, this.qprimeprime(bez, u));
        if (denominator === 0) {
            return u;
        }
        else {
            return u - (numerator / denominator);
        }
    }
    static chordLengthParameterize(points) {
        var u = [], currU, prevU, prevP;
        points.forEach((p, i) => {
            currU = i ? prevU + this.vectorLen(this.subtract(p, prevP))
                : 0;
            u.push(currU);
            prevU = currU;
            prevP = p;
        });
        u = u.map(x => x / prevU);
        return u;
    }
    static computeMaxError(points, bez, parameters) {
        var dist, //Current error
        maxDist, //Maximum error
        splitPoint, //Point of maximum error
        v, //Vector from point to curve
        i, count, point, t;
        maxDist = 0;
        splitPoint = points.length / 2;
        const t_distMap = this.mapTtoRelativeDistances(bez, 10);
        for (i = 0, count = points.length; i < count; i++) {
            point = points[i];
            //Find 't' for a point on the bez curve that's as close to 'point' as possible:
            t = this.find_t(bez, parameters[i], t_distMap, 10);
            v = this.subtract(this.q(bez, t), point);
            dist = v[0] * v[0] + v[1] * v[1];
            if (dist > maxDist) {
                maxDist = dist;
                splitPoint = i;
            }
        }
        return [maxDist, splitPoint];
    }
    static mapTtoRelativeDistances(bez, B_parts) {
        var B_t_curr;
        var B_t_dist = [0];
        var B_t_prev = bez[0];
        var sumLen = 0;
        for (var i = 1; i <= B_parts; i++) {
            B_t_curr = this.q(bez, i / B_parts);
            sumLen += this.vectorLen(this.subtract(B_t_curr, B_t_prev));
            B_t_dist.push(sumLen);
            B_t_prev = B_t_curr;
        }
        //Normalize B_length to the same interval as the parameter distances; 0 to 1:
        B_t_dist = B_t_dist.map(x => x / sumLen);
        return B_t_dist;
    }
    static find_t(bez, param, t_distMap, B_parts) {
        if (param < 0) {
            return 0;
        }
        if (param > 1) {
            return 1;
        }
        
        var lenMax, lenMin, tMax, tMin, t;
        //Find the two t-s that the current param distance lies between,
        //and then interpolate a somewhat accurate value for the exact t:
        for (var i = 1; i <= B_parts; i++) {
            if (param <= t_distMap[i]) {
                tMin = (i - 1) / B_parts;
                tMax = i / B_parts;
                lenMin = t_distMap[i - 1];
                lenMax = t_distMap[i];
                t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
                break;
            }
        }
        return t;
    }
    static createTangent(pointA, pointB) {
        return this.normalize(this.subtract(pointA, pointB));
    }
    //--math --
    static zeros_Xx2x2(x) {
        var zs = [];
        while (x--) {
            zs.push([0, 0]);
        }
        return zs;
    }
    //multiply = logAndRun(math.multiply);
    static mulItems(items, multiplier) {
        //return items.map(x => x*multiplier);
        return [items[0] * multiplier, items[1] * multiplier];
    }
    static mulMatrix(m1, m2) {
        //https://en.wikipedia.org/wiki/Matrix_multiplication#Matrix_product_.28two_matrices.29
        //Simplified to only handle 1-dimensional matrices (i.e. arrays) of equal length:
        //  return m1.reduce((sum,x1,i) => sum + (x1*m2[i]),
        //                   0);
        return (m1[0] * m2[0]) + (m1[1] * m2[1]);
    }
    //Only used to subract to points (or at least arrays):
    //  subtract = logAndRun(math.subtract);
    static subtract(arr1, arr2) {
        //return arr1.map((x1, i) => x1 - arr2[i]);
        return [arr1[0] - arr2[0], arr1[1] - arr2[1]];
    }
    //add = logAndRun(math.add);
    static addArrays(arr1, arr2) {
        //return arr1.map((x1, i) => x1 + arr2[i]);
        return [arr1[0] + arr2[0], arr1[1] + arr2[1]];
    }
    static addItems(items, addition) {
        //return items.map(x => x+addition);
        return [items[0] + addition, items[1] + addition];
    }
    //var sum = logAndRun(math.sum);
    static sum(items) {
        return items.reduce((sum, x) => sum + x);
    }
    //chain = math.chain;
    //Only used on two arrays. The dot product is equal to the matrix product in this case:
    //  dot = logAndRun(math.dot);
    static dot(m1, m2) {
        return this.mulMatrix(m1, m2);
    }
    //https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm
    //  var norm = logAndRun(math.norm);
    static vectorLen(v) {
        var a = v[0], b = v[1];
        return Math.sqrt(a * a + b * b);
    }
    //math.divide = logAndRun(math.divide);
    static divItems(items, divisor) {
        //return items.map(x => x/divisor);
        return [items[0] / divisor, items[1] / divisor];
    }
    //var dotPow = logAndRun(math.dotPow);
    static squareItems(items) {
        //return items.map(x => x*x);
        var a = items[0], b = items[1];
        return [a * a, b * b];
    }
    static normalize(v) {
        return this.divItems(v, this.vectorLen(v));
    }
    //--- bezier
    //Evaluates cubic bezier at t, return point
    static q(ctrlPoly, t) {
        var tx = 1.0 - t;
        var pA = this.mulItems(ctrlPoly[0], tx * tx * tx), pB = this.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = this.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = this.mulItems(ctrlPoly[3], t * t * t);
        return this.addArrays(this.addArrays(pA, pB), this.addArrays(pC, pD));
    }
    //Evaluates cubic bezier first derivative at t, return point
    static qprime(ctrlPoly, t) {
        var tx = 1.0 - t;
        var pA = this.mulItems(this.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = this.mulItems(this.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = this.mulItems(this.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
        return this.addArrays(this.addArrays(pA, pB), pC);
    }
    //Evaluates cubic bezier second derivative at t, return point
    static qprimeprime(ctrlPoly, t) {
        return this.addArrays(this.mulItems(this.addArrays(this.subtract(ctrlPoly[2], this.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), this.mulItems(this.addArrays(this.subtract(ctrlPoly[3], this.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
    }
}
//# sourceMappingURL=FitCurve.js.map

class BorderVectorizer {
    constructor() {
        if (BorderVectorizer._instance) {
            throw new Error("You must use BorderVectorizer.instance");
        }
        BorderVectorizer._instance = this;
    }
    static get instance() {
        if (!BorderVectorizer._instance)
            new BorderVectorizer();
        return BorderVectorizer._instance;
    }
    init(maxPointWanted, borderPoints) {
        this.sourcePoints = borderPoints;
        this.nbPointMax = maxPointWanted;
        this.points = borderPoints.concat();
        this.firstPt = borderPoints[0];
        this.process();
        return this.points;
    }
    removeNearestPoints(a) {
        var i;
        var v = this.points;
        //console.log("before => ",v.length);
        v.push(v[0]);
        v.push(v[1]);
        var limitAngle = Math.PI / 180 * a;
        var a1, a2;
        var p0, p1, p2;
        var p0x, p0y, p1x, p1y, p2x, p2y;
        var dx, dy;
        for (i = 2; i < v.length; i++) {
            p0x = v[i - 1].x;
            p0y = v[i - 1].y;
            p1x = v[i].x;
            p1y = v[i].y;
            dx = p0x - p1x;
            dy = p1y - p1y;
            a1 = Math.atan2(dy, dx);
            dx = v[i - 2].x - p0x;
            dy = v[i - 2].y - p0y;
            a2 = Math.atan2(dy, dx);
            if (a1 - a2 < limitAngle) {
                v.splice(i, 1);
            }
        }
        v.pop();
        //console.log("after = " + v.length);
        this.points = v;
    }
    process() {
        //by default, the process apply a very strong optimization of the path.
        //I wrote that class to convert a pixel-path made of hundreds/thousands of pixels
        //into the minimal amount of point possible with approximatly the same shape
        //I did it to convert a custom-pixel-shape into Box2D-polygon
        //console.log("NB POINT BEFORE OPTIMISATION : "+this.points.length+"      ---  nbWanted = "+this.nbPointMax);
        var startLen = this.points.length;
        var len = this.points.length;
        var count = 1;
        var maxPoint = this.nbPointMax; // * 1.35;// int(points.length / 40);
        var num = 0;
        var b = false;
        var numIncrement = 1; //+ (0.5 +numPass/20) / 5;
        var oldLen = -1;
        var o12 = new BorderLinePt();
        var o23 = new BorderLinePt();
        var o31 = new BorderLinePt();
        var linePoints = [];
        linePoints[0] = o12;
        linePoints[1] = o23;
        linePoints[2] = o31;
        var points = this.points;
        while (len > maxPoint) {
            num += numIncrement;
            if (len > maxPoint) {
                o12.reset();
                o23.reset();
                o31.reset();
                let limit = num;
                let maxRemove = len - maxPoint;
                let dx, dy;
                let i;
                let p1, p2, p3;
                let center, opposite;
                let oppositeId;
                let opposites = [];
                let o1x, o1y, o2x, o2y, o3x, o3y, a, d;
                let hypothenus;
                let multi;
                let nbRemove = 0;
                let k = 0;
                for (i = 2; i < points.length - 1; i += 2) {
                    p1 = points[i - 2];
                    p2 = points[i - 1];
                    p3 = points[i];
                    o1x = p1.x;
                    o1y = p1.y;
                    o2x = p2.x;
                    o2y = p2.y;
                    o3x = p3.x;
                    o3y = p3.y;
                    multi = 100000; //used to maximize the chance to have 3 different distance for the Collection.sort;
                    o12.id = i - 2;
                    o12.p1 = p1;
                    o12.p2 = p2;
                    dx = p1.x - p2.x;
                    dy = p1.y - p2.y;
                    o12.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
                    o12.a = Math.atan2(dy, dx);
                    o23.id = i - 1;
                    o23.p1 = p2;
                    o23.p2 = p3;
                    dx = p2.x - p3.x;
                    dy = p2.y - p3.y;
                    o23.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
                    o23.a = Math.atan2(dy, dx);
                    o31.id = i;
                    o31.p1 = p3;
                    o31.p2 = p1;
                    dx = p3.x - p1.x;
                    dy = p3.y - p1.y;
                    o31.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
                    o31.a = Math.atan2(dy, dx);
                    linePoints = linePoints.sort(this.sortDist);
                    hypothenus = linePoints[2];
                    center = hypothenus.p1;
                    opposite = linePoints[0].p1;
                    oppositeId = linePoints[0].id;
                    if (opposite == hypothenus.p2) {
                        opposite = linePoints[1].p1;
                        oppositeId = linePoints[1].id;
                    }
                    dx = center.x - opposite.x;
                    dy = center.y - opposite.y;
                    a = Math.atan2(dy, dx);
                    d = Math.sqrt(dx * dx + dy * dy);
                    opposite.x = (center.x + Math.cos(-hypothenus.a + a) * d) >> 0; // val >> 0 == int(val)
                    opposite.y = (center.y + Math.sin(-hypothenus.a + a) * d) >> 0;
                    dy = Math.abs(opposite.y - center.y);
                    p1.x = o1x >> 0; //val >> 0 == int(val)
                    p1.y = o1y >> 0;
                    p2.x = o2x >> 0;
                    p2.y = o2y >> 0;
                    p3.x = o3x >> 0;
                    p3.y = o3y >> 0;
                    if (dy < limit)
                        opposites[k++] = { d: dy, id: oppositeId };
                }
                if (opposites.length > maxRemove) {
                    //console.log("aaaaaaaaaaaaa")
                    opposites = opposites.sort(this.sortDist);
                    opposites = opposites.slice(0, maxRemove);
                }
                opposites = opposites.sort(this.sortId);
                for (i = opposites.length - 1; i >= 0; i--) {
                    oppositeId = opposites[i].id;
                    this.points.splice(oppositeId, 1);
                }
                //this.removeNearLine2(num,len-maxPoint);
            }
            oldLen = len;
            len = this.points.length;
            if (oldLen == len)
                count++;
        }
        //console.log("num = ",num,maxPoint)
        //console.log(this.nbPointMax, "wanted | NB POINT AFTER OPTIMISATION : "+this.points.length+" ( "+((this.points.length / startLen)*100.0)+" % of the original )");
    }
    getBackOriginalScale() {
        this.minX = 100000;
        var maxX = 0;
        this.minY = 100000;
        var maxY = 0;
        var i, k = 0, len = this.sourcePoints.length;
        var point;
        for (i = 0; i < len; i++) {
            point = this.sourcePoints[i];
            if (this.sourcePoints[i] == null)
                continue;
            point.x /= this.scale;
            point.y /= this.scale;
        }
        if (this.points[0] == this.points[this.points.length - 1])
            len--;
        len = this.points.length;
        var temp = [];
        for (i = 0; i < len; i++) {
            if (this.points[i] == null)
                continue;
            point = this.points[i];
            temp[k++] = new BorderPt(point.x, point.y, 0);
            if (point.x < this.minX)
                this.minX = point.x;
            if (point.y < this.minY)
                this.minY = point.y;
            if (point.x > maxX)
                maxX = point.x;
            if (point.y > maxY)
                maxY = point.y;
        }
        this.width = maxX - this.minX;
        this.height = maxY - this.minY;
        var temp2 = temp.concat();
        temp2[k - 1] = this.firstPt;
        this.points = temp2;
    }
    rescaleBorderBeforeSimplificationIfPictureIsTooSmall(forceScale = 0) {
        var _minX = 100000, _maxX = 0;
        var _minY = 100000, _maxY = 0;
        var i;
        var len = this.points.length;
        var point;
        for (i = 0; i < len; i++) {
            point = this.points[i];
            if (point.x < _minX)
                _minX = point.x;
            if (point.y < _minY)
                _minY = point.y;
            if (point.x > _maxX)
                _maxX = point.x;
            if (point.y > _maxY)
                _maxY = point.y;
        }
        var w = _maxX - _minX;
        var h = _maxY - _minY;
        var wh = w * h;
        if (!forceScale)
            this.scale = ((1000.0 * 1000.0) / wh);
        else
            this.scale = forceScale;
        for (i = 0; i < this.points.length; i++) {
            this.points[i].x *= this.scale;
            this.points[i].y *= this.scale;
        }
    }
    removeSmallLines(minDist, direction, maxRemove = 9999) {
        var temp = [];
        var i, k = 0, len = this.points.length;
        if (direction)
            temp[k++] = this.points[0];
        else
            temp[k++] = this.points[this.points.length - 1];
        var p0, p1;
        var dx, dy, d;
        var oldDist = 0;
        if (direction == true) {
            for (i = 1; i < len; i++) {
                p0 = this.points[i - 1];
                p1 = this.points[i];
                dx = p0.x - p1.x;
                dy = p0.y - p1.y;
                d = Math.sqrt(dx * dx + dy * dy);
                if (oldDist + d > minDist || k >= maxRemove) {
                    temp[k++] = p1;
                    oldDist = (oldDist + d - minDist) % minDist;
                }
                else {
                    oldDist += d;
                    
                }
            }
        }
        else {
            for (i = len - 2; i > -1; i--) {
                p0 = this.points[i + 1];
                p1 = this.points[i];
                dx = p0.x - p1.x;
                dy = p0.y - p1.y;
                d = Math.sqrt(dx * dx + dy * dy);
                if (oldDist + d > minDist || k >= maxRemove) {
                    temp[k++] = p1;
                    oldDist = (oldDist + d - minDist) % minDist;
                }
                else {
                    oldDist += d;
                    
                }
            }
        }
        this.points = temp;
        return temp;
    }
    removeNearLine(limit, maxRemove = 9999) {
        //it does almost the same thing than the function "simplify"
        //but because it's not based on the "direction-datas" given by the BorderFinder class
        //it's possible to apply with multiple pass and get better results
        //For example, if I have 3 following points of a path like that
        //
        //  0
        //               1
        //
        //
        //                  2
        //the algo loop on every points and create a virtual 4th point at the center of the hypothenus, like that
        //
        //  0
        //               1
        //          4
        //
        //                  2
        //then it will compute the distance between 4 and 1
        //if the distance is smaller than the variable "limit"
        //I remove the point 1 (the point 4 is just an abstraction, it is never added to the point-list
        var dx, dy;
        var i;
        var p1, p2, p3;
        var o12 = new BorderLinePt();
        var o23 = new BorderLinePt();
        var o31 = new BorderLinePt();
        var center, opposite;
        var oppositeId;
        var o1x, o1y, o2x, o2y, o3x, o3y;
        var linePoints = [];
        linePoints[0] = o12;
        linePoints[1] = o23;
        linePoints[2] = o31;
        var multi;
        var nbRemove = 0;
        for (i = 2; i < this.points.length - 1; i += 2) {
            p1 = this.points[i - 2];
            p2 = this.points[i - 1];
            p3 = this.points[i];
            o1x = p1.x;
            o1y = p1.y;
            o2x = p2.x;
            o2y = p2.y;
            o3x = p3.x;
            o3y = p3.y;
            multi = 100000; //used to maximize the chance to have 3 different distance for the Collection.sort;
            o12.id = i - 2;
            o12.p1 = p1;
            o12.p2 = p2;
            dx = p1.x - p2.x;
            dy = p1.y - p2.y;
            o12.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o12.a = Math.atan2(dy, dx);
            o23.id = i - 1;
            o23.p1 = p2;
            o23.p2 = p3;
            dx = p2.x - p3.x;
            dy = p2.y - p3.y;
            o23.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o23.a = Math.atan2(dy, dx);
            o31.id = i;
            o31.p1 = p3;
            o31.p2 = p1;
            dx = p3.x - p1.x;
            dy = p3.y - p1.y;
            o31.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o31.a = Math.atan2(dy, dx);
            //linePoints.sortOn("d", Array.NUMERIC);
            function sortFunc(a, b) {
                if (a.d > b.d)
                    return 1;
                if (a.d < b.d)
                    return -1;
                return 0;
            }
            linePoints = linePoints.sort(sortFunc);
            var hypothenus = linePoints[2];
            center = hypothenus.p1;
            opposite = linePoints[0].p1;
            oppositeId = linePoints[0].id;
            if (opposite == hypothenus.p2) {
                opposite = linePoints[1].p1;
                oppositeId = linePoints[1].id;
            }
            dx = center.x - opposite.x;
            dy = center.y - opposite.y;
            var a = Math.atan2(dy, dx);
            var d = Math.sqrt(dx * dx + dy * dy);
            opposite.x = (center.x + Math.cos(-hypothenus.a + a) * d) >> 0; // val >> 0 == int(val)
            opposite.y = (center.y + Math.sin(-hypothenus.a + a) * d) >> 0;
            dy = Math.abs(opposite.y - center.y);
            p1.x = o1x >> 0; //val >> 0 == int(val)
            p1.y = o1y >> 0;
            p2.x = o2x >> 0;
            p2.y = o2y >> 0;
            p3.x = o3x >> 0;
            p3.y = o3y >> 0;
            if (dy < limit) {
                this.points.splice(oppositeId, 1);
                var p = this.points[oppositeId];
                
                nbRemove++;
                if (nbRemove == maxRemove)
                    break;
            }
        }
        return this.points;
    }
    sortDist(a, b) {
        if (a.d > b.d)
            return 1;
        if (a.d < b.d)
            return -1;
        return 0;
    }
    sortId(a, b) {
        if (a.id > b.id)
            return 1;
        if (a.id < b.id)
            return -1;
        return 0;
    }
    removeNearLine2(limit, maxRemove = 9999) {
        //it does almost the same thing than the function "simplify"
        //but because it's not based on the "direction-datas" given by the BorderFinder class
        //it's possible to apply with multiple pass and get better results
        //For example, if I have 3 following points of a path like that
        //
        //  0
        //               1
        //
        //
        //                  2
        //the algo loop on every points and create a virtual 4th point at the center of the hypothenus, like that
        //
        //  0
        //               1
        //          4
        //
        //                  2
        //then it will compute the distance between 4 and 1
        //if the distance is smaller than the variable "limit"
        //I remove the point 1 (the point 4 is just an abstraction, it is never added to the point-list
        
        var dx, dy;
        var i;
        var p1, p2, p3;
        var o12 = new BorderLinePt();
        var o23 = new BorderLinePt();
        var o31 = new BorderLinePt();
        var center, opposite;
        var oppositeId;
        var opposites = [];
        var o1x, o1y, o2x, o2y, o3x, o3y;
        var linePoints = [];
        linePoints[0] = o12;
        linePoints[1] = o23;
        linePoints[2] = o31;
        var multi;
        var nbRemove = 0;
        var k = 0;
        for (i = 2; i < this.points.length - 1; i += 2) {
            p1 = this.points[i - 2];
            p2 = this.points[i - 1];
            p3 = this.points[i];
            o1x = p1.x;
            o1y = p1.y;
            o2x = p2.x;
            o2y = p2.y;
            o3x = p3.x;
            o3y = p3.y;
            multi = 100000; //used to maximize the chance to have 3 different distance for the Collection.sort;
            o12.id = i - 2;
            o12.p1 = p1;
            o12.p2 = p2;
            dx = p1.x - p2.x;
            dy = p1.y - p2.y;
            o12.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o12.a = Math.atan2(dy, dx);
            o23.id = i - 1;
            o23.p1 = p2;
            o23.p2 = p3;
            dx = p2.x - p3.x;
            dy = p2.y - p3.y;
            o23.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o23.a = Math.atan2(dy, dx);
            o31.id = i;
            o31.p1 = p3;
            o31.p2 = p1;
            dx = p3.x - p1.x;
            dy = p3.y - p1.y;
            o31.d = (Math.sqrt(dx * dx + dy * dy) * multi) >> 0;
            o31.a = Math.atan2(dy, dx);
            //linePoints.sortOn("d", Array.NUMERIC);
            linePoints = linePoints.sort(this.sortDist);
            var hypothenus = linePoints[2];
            center = hypothenus.p1;
            opposite = linePoints[0].p1;
            oppositeId = linePoints[0].id;
            if (opposite == hypothenus.p2) {
                opposite = linePoints[1].p1;
                oppositeId = linePoints[1].id;
            }
            dx = center.x - opposite.x;
            dy = center.y - opposite.y;
            var a = Math.atan2(dy, dx);
            var d = Math.sqrt(dx * dx + dy * dy);
            opposite.x = (center.x + Math.cos(-hypothenus.a + a) * d) >> 0; // val >> 0 == int(val)
            opposite.y = (center.y + Math.sin(-hypothenus.a + a) * d) >> 0;
            dy = Math.abs(opposite.y - center.y);
            p1.x = o1x >> 0; //val >> 0 == int(val)
            p1.y = o1y >> 0;
            p2.x = o2x >> 0;
            p2.y = o2y >> 0;
            p3.x = o3x >> 0;
            p3.y = o3y >> 0;
            if (dy < limit) {
                
                opposites[k++] = { d: dy, id: oppositeId };
                //opposites.push({d:dy,id:oppositeId})
            }
        }
        if (opposites.length > maxRemove) {
            //console.log("aaaaaaaaaaaaa")
            opposites = opposites.sort(this.sortDist);
            opposites = opposites.slice(0, maxRemove);
        }
        opposites = opposites.sort(this.sortId);
        for (i = opposites.length - 1; i >= 0; i--) {
            oppositeId = opposites[i].id;
            this.points.splice(oppositeId, 1);
            
        }
        return this.points;
    }
}
//# sourceMappingURL=BorderVectorizer.js.map

class Filter extends DirtyEventDispatcher {
    constructor() {
        super();
        this.boundOffsetW = 0;
        this.boundOffsetH = 0;
        this.next = null;
        this._offsetX = 0;
        this._offsetY = 0;
        this._radius = 0;
        this._intensity = 0;
        this._angle = 0;
        var th = this;
        this._updateColor = function () {
            th.dirty = true;
            th.applyDirty();
        };
    }
    get value() { return null; }
    get angle() { return this._angle; }
    set angle(n) {
        if (n != this._angle) {
            this._angle = n;
        }
    }
    get color() { return this._color; }
    set color(c) {
        if (c != this._color) {
            if (this._color)
                this._color.removeEventListener(SolidColor.UPDATE_STYLE, this._updateColor);
            this._color = c;
            this._color.addEventListener(SolidColor.UPDATE_STYLE, this._updateColor);
            this.applyDirty();
        }
    }
    get intensity() { return this._intensity; }
    set intensity(n) {
        if (n != this._intensity) {
            this._intensity = n;
            this.applyDirty();
        }
    }
    get offsetX() { return this._offsetX; }
    set offsetX(n) {
        if (n != this._offsetX) {
            this._offsetX = n;
            this.boundOffsetW = Math.abs(n) + this.radius;
            this.applyDirty();
        }
    }
    get offsetY() { return this._offsetX; }
    set offsetY(n) {
        if (n != this._offsetY) {
            this._offsetY = n;
            this.boundOffsetH = Math.abs(n) + this.radius;
            this.applyDirty();
        }
    }
    get radius() { return this._radius; }
    set radius(n) {
        if (n != this._radius) {
            this._radius = n;
            this.boundOffsetW = Math.abs(this._offsetX) + n;
            this.boundOffsetH = Math.abs(this._offsetY) + n;
            this.applyDirty();
        }
    }
    clear() {
        for (var z in this)
            this[z] = null;
    }
}
//# sourceMappingURL=Filter.js.map
class FilterStack extends RegisterableObject {
    //public cacheAsBitmap:boolean = false;
    constructor() {
        super();
        this.dirty = true;
        this.boundOffsetW = 0;
        this.boundOffsetH = 0;
    }
    clear() {
        let f = this.first;
        while (f) {
            f.clear();
            f = f.next;
        }
    }
    clone(cloneFilters = false) {
        let f = this.first;
        const s = new FilterStack();
        while (f) {
            if (cloneFilters)
                s.add(f.clone());
            else
                s.add(f);
        }
        return s;
    }
    get value() {
        if (this.dirty) {
            //console.log(this.dirty)
            let v = "";
            let f = this.first;
            let w = 0, h = 0;
            while (f) {
                v = v + f.value + " ";
                if (f.boundOffsetW > w)
                    w = f.boundOffsetW;
                if (f.boundOffsetH > h)
                    h = f.boundOffsetH;
                f = f.next;
            }
            this.boundOffsetW = w;
            this.boundOffsetH = h;
            this._value = v;
            this.dirty = false;
        }
        return this._value;
    }
    get dataString() {
        var s = "";
        var o = this.first;
        var b = false;
        while (o) {
            if (b)
                s += ",";
            s += o.REGISTER_ID;
            b = true;
            o = o.next;
        }
        return s;
    }
    static fromDataString(data) {
        var t = data.split(",");
        var s = new FilterStack();
        var i, len = t.length;
        for (i = 0; i < len; i++)
            s.add(ObjectLibrary.instance.getObjectByRegisterId(t[i]));
        return s;
    }
    add(filter) {
        if (!this.first)
            this.first = filter;
        if (this.last)
            this.last.next = filter;
        this.last = filter;
        filter.addDirtyEventTarget(this);
        return this;
    }
}
//# sourceMappingURL=FilterStack.js.map
class BlurFilter extends Filter {
    constructor(intensity = 0) {
        super();
        this.radius = intensity;
    }
    get dataString() { return "" + this.radius; }
    static fromDataString(data) { return new BlurFilter(Number(data)); }
    clone() { return new BlurFilter(this.radius); }
    get value() { return "blur(" + this.radius + "+px)"; }
}
//# sourceMappingURL=BlurFilter.js.map
class BrightnessFilter extends Filter {
    constructor(intensity = 0) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new BrightnessFilter(Number(data)); }
    clone() { return new BrightnessFilter(this._intensity); }
    get value() { return "brightness(" + this._intensity + "+%)"; }
}
//# sourceMappingURL=BrightnessFilter.js.map
class ContrastFilter extends Filter {
    constructor(intensity = 0) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new ContrastFilter(Number(data)); }
    clone() { return new ContrastFilter(this._intensity); }
    get value() { return "contrast(" + this._intensity + "+%)"; }
}
//# sourceMappingURL=ContrastFilter.js.map
class DropShadowFilter extends Filter {
    constructor(offsetX, offsetY, radius, color) {
        super();
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.radius = radius;
        if (color instanceof SolidColor)
            this.color = color;
        else
            this.color = new SolidColor(color);
        //this.color.addEventListener(SolidColor.UPDATE_STYLE,this._updateColor)
    }
    get dataString() {
        return [this.offsetX, this.offsetY, this.radius, this.color.REGISTER_ID].join(",");
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new DropShadowFilter(Number(t[0]), Number(t[1]), Number(t[2]), ObjectLibrary.instance.getObjectByRegisterId(t[3]));
    }
    clone(cloneColor = false) {
        if (!cloneColor)
            return new DropShadowFilter(this._offsetX, this._offsetY, this._radius, this._color);
        return new DropShadowFilter(this._offsetX, this._offsetY, this._radius, this._color.clone());
    }
    get value() { return "drop-shadow(" + this._offsetX + "px " + this._offsetY + "px " + this._radius + "px " + this._color.style + ") "; }
}
//# sourceMappingURL=DropShadowFilter.js.map
class GlowFilter extends DropShadowFilter {
    constructor(radius, color) {
        super(0, 0, radius, color);
    }
    get dataString() {
        return this.radius + "," + this.color.REGISTER_ID;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new GlowFilter(Number(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]));
    }
    clone(cloneColor = false) {
        if (cloneColor)
            return new GlowFilter(this._radius, this._color.clone());
        return new GlowFilter(this._radius, this._color);
    }
}
//# sourceMappingURL=GlowFilter.js.map
class GrayscaleFilter extends Filter {
    constructor(intensity = 0) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new GrayscaleFilter(Number(data)); }
    clone() { return new GrayscaleFilter(this._intensity); }
    get value() { return "grayscale(" + this._intensity + "+%)"; }
}
//# sourceMappingURL=GrayscaleFilter.js.map
class HueRotateFilter extends Filter {
    constructor(angle = 0) {
        super();
        this._angle = angle;
    }
    get dataString() { return "" + this._angle; }
    static fromDataString(data) { return new HueRotateFilter(Number(data)); }
    get value() { return "hue-rotate(" + this._angle + "+%)"; }
    clone() { return new HueRotateFilter(this._angle); }
}
//# sourceMappingURL=HueRotateFilter.js.map
class InvertFilter extends Filter {
    constructor(intensity = 0) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new InvertFilter(Number(data)); }
    get value() { return "invert(" + this._intensity + "+%)"; }
    clone() { return new InvertFilter(this._intensity); }
}
//# sourceMappingURL=InvertFilter.js.map
class OpacityFilter extends Filter {
    constructor(intensity = 3) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new OpacityFilter(Number(data)); }
    get value() { return "opacity(" + this._intensity + "+%)"; }
    clone() { return new OpacityFilter(this._intensity); }
}
//# sourceMappingURL=OpacityFilter.js.map
class SaturatetFilter extends Filter {
    constructor(intensity = 3) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new SaturatetFilter(Number(data)); }
    get value() { return "saturate(" + this._intensity + "+%)"; }
    clone() { return new SaturatetFilter(this._intensity); }
}
//# sourceMappingURL=SaturateFilter.js.map
class SepiaFilter extends Filter {
    constructor(intensity = 3) {
        super();
        this._intensity = intensity;
    }
    get dataString() { return "" + this._intensity; }
    static fromDataString(data) { return new SepiaFilter(Number(data)); }
    get value() { return "sepia(" + this._intensity + "+%)"; }
    clone() { return new SepiaFilter(this._intensity); }
}
//# sourceMappingURL=SepiaFilter.js.map
class SVGFilter extends Filter {
    constructor(url) {
        super();
        this._url = url;
    }
    get dataString() { return "" + this._url; }
    static fromDataString(data) { return new SVGFilter(data); }
    get url() { return this._url; }
    set url(n) {
        if (n != this._url) {
            this._url = n;
            this.applyDirty();
        }
    }
    get value() { return "url(" + this._url + "+)"; }
    clone() { return new SVGFilter(this._url); }
}
//# sourceMappingURL=SVGFilter.js.map
class LineStyle extends RegisterableObject {
    constructor(lineWidth = null) {
        super();
        this.cap = null;
        this.dashOffset = null;
        this.dashLineDist = null;
        this.dashHoleDist = null;
        this.join = null;
        this.lineWidth = null;
        this.miterLimit = null;
        this.allowScaleTransform = true;
        this.lineWidth = lineWidth;
    }
    get dataString() {
        return [this.lineWidth, this.cap, this.dashOffset, this.dashLineDist, this.dashHoleDist, this.join, this.miterLimit, Number(this.allowScaleTransform)].join(",");
    }
    static fromDataString(data) {
        var t = data.split(",");
        var o = new LineStyle(Number(t[0]));
        if (t[1] != "null")
            o.cap = t[1];
        if (t[2] != "null")
            o.dashOffset = Number(t[2]);
        if (t[3] != "null")
            o.dashLineDist = Number(t[3]);
        if (t[4] != "null")
            o.dashHoleDist = Number(t[4]);
        if (t[5] != "null")
            o.join = t[5];
        if (t[6] != "null")
            o.miterLimit = Number(t[6]);
        o.allowScaleTransform = t[7] == "1";
        return o;
    }
    clone() {
        var o = new LineStyle(this.lineWidth);
        o.cap = this.cap;
        o.dashOffset = this.dashOffset;
        o.dashHoleDist = this.dashHoleDist;
        o.dashLineDist = this.dashLineDist;
        o.join = this.join;
        o.miterLimit = this.miterLimit;
        return o;
    }
    apply(context, path, target) {
        if (this.cap)
            context.lineCap = this.cap;
        if (this.join)
            context.lineJoin = this.join;
        if (this.lineWidth)
            context.lineWidth = this.lineWidth;
        if (this.miterLimit)
            context.miterLimit = this.miterLimit;
        let sx = 1, sy = 1;
        if (this.allowScaleTransform) {
            sx = target.scaleX;
            sy = target.scaleY;
        }
        let s = Math.max(target.width / sx, target.height / sy);
        let s2 = Math.min(target.width, target.height);
        if (this.dashOffset)
            context.lineDashOffset = this.dashOffset;
        if (this.dashLineDist) {
            if (this.dashHoleDist)
                context.setLineDash([this.dashLineDist / s, this.dashHoleDist / s]);
            else
                context.setLineDash([this.dashLineDist / s]);
        }
        context.lineWidth = this.lineWidth / s2;
    }
}
//# sourceMappingURL=LineStyle.js.map
class TextStyle extends RegisterableObject {
    constructor(fontName, fontSize, sizeMeasure = "px", offsetX = 0, offsetY = 0, allowScaleTransform = false) {
        super();
        this.sizeMeasure = "px";
        this.offsetX = 0;
        this.offsetY = 0;
        this.lineStyle = null;
        this.allowScaleTransform = false;
        this.fontName = fontName;
        this.fontSize = fontSize;
        this.sizeMeasure = sizeMeasure;
        this.offsetX = offsetX + fontSize * 0.2;
        this.offsetY = offsetY + fontSize * 0.85;
        this.allowScaleTransform = allowScaleTransform;
    }
    get dataString() {
        return [this.fontName, this.fontSize, this.sizeMeasure, this.offsetX, this.offsetY, Number(this.allowScaleTransform)].join(",");
    }
    static fromDataString(data) {
        let t = data.split(",");
        let o = new TextStyle(t[0], Number(t[1]), t[2], Number(t[3]), Number(t[4]), t[5] == "1");
        return o;
    }
    clone(cloneTextLineStyle = true) {
        let t = null;
        if (this.lineStyle) {
            if (cloneTextLineStyle)
                t = this.lineStyle.clone();
            else
                t = this.lineStyle;
        }
        let s = new TextStyle(this.fontName, this.fontSize, this.sizeMeasure, this.offsetX, this.offsetY);
        s.lineStyle = t;
        return s;
    }
    apply(context, path, target) {
        var s = Math.max(target.width, target.height);
        if (this.lineStyle)
            this.lineStyle.apply(context, path, target);
        context.font = (this.fontSize / s) + this.sizeMeasure + " " + this.fontName;
        if (this.allowScaleTransform == false)
            context.scale(1 / target.scaleX, 1 / target.scaleY);
    }
}
//# sourceMappingURL=TextStyle.js.map
class CssFilter {
    constructor(cssFilterValue = null) {
        this.filter = "";
        this.clear();
        if (cssFilterValue)
            this.filter = cssFilterValue;
    }
    clear() {
        this.filter = "";
        this.offsetX = this.offsetY = 0;
    }
    dropShadow(offsetX, offsetY, radius, color) {
        //offsetX *= this.screenScale;
        //offsetY *= this.screenScale;
        //radius *= this.screenScale;
        this.filter += "drop-shadow(" + offsetX + "px " + offsetY + "px " + radius + "px " + color + ") ";
        //console.log(radius)
        var ox = Math.abs(offsetX) + radius * 4;
        var oy = Math.abs(offsetY) + radius * 4;
        if (this.offsetX < ox)
            this.offsetX = ox;
        if (this.offsetY < oy)
            this.offsetY = oy;
        return this;
    }
    blur(intensity) {
        //intensity *= this.screenScale;
        this.filter += "blur(" + intensity + "px) ";
        intensity *= Math.sqrt(2);
        if (this.offsetX < intensity)
            this.offsetX = intensity;
        if (this.offsetY < intensity)
            this.offsetY = intensity;
        return this;
    }
    halo(intensity, color = "#ffffff") {
        //intensity *= this.screenScale;
        
        this.dropShadow(0, 0, intensity, color);
        return this;
    }
    brightness(intensity = 0.5) {
        this.filter += "brightness(" + intensity + ") ";
        return this;
    }
    contrast(intensity = 1.5) {
        intensity *= 100;
        this.filter += "contrast(" + intensity + "%) ";
        return this;
    }
    grayscale(intensity = 0.5) {
        intensity *= 100;
        this.filter += "grayscale(" + intensity + "%) ";
        return this;
    }
    hueRotate(angleInDegree = 90) {
        this.filter += "hue-rotate(" + angleInDegree + "deg) ";
        return this;
    }
    invert(intensity = 0.5) {
        intensity *= 100;
        this.filter += "invert(" + intensity + "%) ";
        return this;
    }
    opacity(intensity = 0.5) {
        intensity *= 100;
        this.filter += "opacity(" + intensity + "%) ";
        return this;
    }
    saturate(intensity = 0.5) {
        intensity *= 100;
        this.filter += "saturate(" + intensity + "%) ";
        return this;
    }
    sepia(intensity = 0.5) {
        intensity *= 100;
        this.filter += "sepia(" + intensity + "%) ";
        return this;
    }
}
//# sourceMappingURL=CssFilter.js.map

class TextPath extends RegisterableObject {
    constructor(text) {
        super();
        this.text = text;
    }
    get dataString() { return this.text; }
    static fromDataString(data) { return new TextPath(data); }
    isPointInside(context, px, py, isStroke, fillrule = "nonzero") {
        return false;
    }
    isPointInPath(context, px, py) {
        return false;
    }
    isPointInStroke(context, px, py) {
        return false;
    }
}
//# sourceMappingURL=TextPath.js.map
class FillStroke extends RegisterableObject {
    constructor() {
        super();
        this.fillPathRule = "nonzero";
        this.alpha = 1;
        this.lineStyle = null;
        this.textStyle = null;
        //public filter:CssFilter = null;
        this.filters = null;
        this.needsUpdate = true;
        this.offsetW = 0;
        this.offsetH = 0;
        this.dirty = true;
        this._cacheAsBitmap = false;
        this.cacheDirty = false;
        this.cache = null;
        //this._filters = new FilterStack();
    }
    apply(context, path, target) {
        if (target.fillStrokeDrawable)
            context.globalAlpha = this.alpha * target.realAlpha;
        let css = this.filters;
        if (css) {
            this.dirty = css.dirty;
            if (target.fillStrokeDrawable)
                context.filter = css.value;
            this.offsetW = css.boundOffsetW;
            this.offsetH = css.boundOffsetH;
        }
        else {
            context.filter = "none";
        }
    }
    get cacheAsBitmap() { return this._cacheAsBitmap; }
    set cacheAsBitmap(b) {
        if (this._cacheAsBitmap != b) {
            this._cacheAsBitmap = b;
            if (b)
                this.cacheDirty = true;
        }
    }
    get isFill() { return this.styleType == "fillStyle"; }
    get isStroke() { return this.styleType == "strokeStyle"; }
    get realOffsetW() { return this.offsetW + this.lineWidth; }
    get realOffsetH() { return this.offsetH + this.lineWidth; }
    get lineWidth() {
        if (null == this.lineStyle)
            return 0;
        return this.lineStyle.lineWidth;
    }
}
FillStroke.radian = Math.PI / 180;
//# sourceMappingURL=FillStroke.js.map
class Solid extends FillStroke {
    constructor(r = "#000000", g = null, b = null, a = null) {
        super();
        //r can contains these values :
        //-> 0...255 => as the red component
        //-> 0xrrggbb => RGB hex number
        //-> 0xaarrggbb
        //-> "#rrggbb"
        //--> "#aarrggbb"
        if (r instanceof SolidColor)
            this.color = r;
        else
            this.color = new SolidColor(r, g, b, a);
    }
    clone(cloneColor = false, cloneLineStyle = true, cloneTextStyle = true, cloneTextLineStyle = true) {
        var o;
        if (cloneColor)
            o = new Solid(this.color.clone());
        else
            o = new Solid(this.color);
        o.fillPathRule = this.fillPathRule;
        o.styleType = this.styleType;
        o.alpha = this.alpha;
        if (this.lineStyle) {
            if (cloneLineStyle)
                o.lineStyle = this.lineStyle.clone();
            else
                o.lineStyle = this.lineStyle;
        }
        if (this.textStyle) {
            if (cloneTextStyle)
                o.textStyle = this.textStyle.clone(cloneTextLineStyle);
            else
                o.textStyle = this.textStyle;
        }
        return o;
    }
    apply(context, path, target) {
        super.apply(context, path, target);
        context[this.styleType] = this.color.style;
    }
}
//# sourceMappingURL=Solid.js.map
class Gradient extends FillStroke {
    constructor(gradient, isLinear = true) {
        super();
        this._x = 0; //-> -0.999...+0.999
        this._y = 0; //-> -0.999...+0.999
        this._scaleX = 1;
        this._scaleY = 1;
        this._rotation = 0; // radian
        this._radialFlareX = 0; //-> -0.999...+0.999
        this._radialFlareY = 0; //-> -0.999...+0.999
        this._radialFlareStrength = 1;
        this.dirty = true;
        this._gradient = gradient;
        this._isLinear = isLinear;
    }
    clone(cloneGradient = false, cloneColors = false, cloneLineStyle = true, cloneTextStyle = true, cloneTextLineStyle = true) {
        var o;
        if (cloneGradient)
            o = new Gradient(this._gradient.clone(cloneColors));
        else
            o = new Gradient(this._gradient);
        o.fillPathRule = this.fillPathRule;
        o.styleType = this.styleType;
        o.x = this.x;
        o.y = this.y;
        o.scaleX = this.scaleX;
        o.scaleY = this.scaleY;
        o.rotation = this.rotation;
        o.radialFlareX = this.radialFlareX;
        o.radialFlareY = this.radialFlareY;
        o.radialFlareStrength = this.radialFlareStrength;
        o.alpha = this.alpha;
        if (this.lineStyle) {
            if (cloneLineStyle)
                o.lineStyle = this.lineStyle.clone();
            else
                o.lineStyle = this.lineStyle;
        }
        if (this.textStyle) {
            if (cloneTextStyle)
                o.textStyle = this.textStyle.clone(cloneTextLineStyle);
            else
                o.textStyle = this.textStyle;
        }
        return o;
    }
    get gradient() { return this._gradient; }
    set gradient(n) {
        this._gradient = n;
        this.dirty = true;
    }
    get isLinear() { return this._isLinear; }
    set isLinear(n) {
        this._isLinear = n;
        this.dirty = true;
    }
    get x() { return this._x; }
    set x(n) {
        this._x = n;
        this.dirty = true;
    }
    get y() { return this._x; }
    set y(n) {
        this._y = n;
        this.dirty = true;
    }
    get scaleX() { return this._scaleX; }
    set scaleX(n) {
        this._scaleX = n;
        this.dirty = true;
    }
    get scaleY() { return this._scaleY; }
    set scaleY(n) {
        this._scaleY = n;
        this.dirty = true;
    }
    get rotation() { return this._rotation; }
    set rotation(n) {
        this._rotation = n;
        this.dirty = true;
    }
    get radialFlareX() { return this._radialFlareX; }
    set radialFlareX(n) {
        this._radialFlareX = n;
        this.dirty = true;
    }
    get radialFlareY() { return this._radialFlareY; }
    set radialFlareY(n) {
        this._radialFlareY = n;
        this.dirty = true;
    }
    get radialFlareStrength() { return this._radialFlareStrength; }
    set radialFlareStrength(n) {
        this._radialFlareStrength = n;
        this.dirty = true;
    }
    apply(context, path, target) {
        if (this.dirty || this._gradient.dirty) {
            this._gradient.transformValues(this._x, this._y, this._scaleX, this._scaleY, this._rotation, this._radialFlareX, this._radialFlareY, this._radialFlareStrength);
            this.gradientCanvas = this._gradient.getGradientStyle(context, target);
            this.dirty = false;
        }
        super.apply(context, path, target);
        context[this.styleType] = this.gradientCanvas; //Gradient.gradients[this._name];
    }
}
//# sourceMappingURL=Gradient.js.map
class Pattern extends FillStroke {
    constructor(source, crop = true, applyTargetScale = false) {
        super();
        this.dirty = true;
        this.dirtyMatrix = true;
        this.imageBmp = null;
        this.rotationInDegree = 0;
        this._crop = true;
        this._applyTargetScale = false;
        this.videoUpdate = false;
        this.source = source;
        var th = this;
        this.onImageLoaded = function (e) {
            th.imageBmp = null;
            th.dirty = th.dirtyMatrix = true;
        };
        source.addEventListener(BitmapData.IMAGE_LOADED, this.onImageLoaded);
        this.canvas = source.htmlCanvas;
        this.matrix = new Matrix2D();
        this._crop = crop;
        this._applyTargetScale = applyTargetScale;
    }
    get crop() { return this._crop; }
    set crop(b) {
        if (this._crop != b) {
            this.dirty = this.dirtyMatrix = true;
            this._crop = b;
        }
    }
    get applyTargetScale() { return this._applyTargetScale; }
    set applyTargetScale(b) {
        if (this._applyTargetScale != b) {
            this.dirty = this.dirtyMatrix = true;
            this._crop = b;
        }
    }
    clone(cloneMedia = false, cloneLineStyle = true, cloneTextStyle = true, cloneTextLineStyle = true) {
        var o;
        if (!cloneMedia)
            o = new Pattern(this.source);
        else {
            if (this.source instanceof BitmapData)
                o = new Pattern(this.source.clone());
            else
                o = new Pattern(this.source);
        }
        o.mat.x = this.matrix.x;
        o.mat.y = this.matrix.y;
        o.mat.scaleX = this.matrix.scaleX;
        o.mat.scaleY = this.matrix.scaleY;
        o.mat.rotation = this.matrix.rotation;
        o.mat.width = this.matrix.width;
        o.mat.height = this.matrix.height;
        o.mat.setMatrixValue(this.matrix.toString());
        o.fillPathRule = this.fillPathRule;
        o.styleType = this.styleType;
        if (this.lineStyle) {
            if (cloneLineStyle)
                o.lineStyle = this.lineStyle.clone();
            else
                o.lineStyle = this.lineStyle;
        }
        if (this.textStyle) {
            if (cloneTextStyle)
                o.textStyle = this.textStyle.clone(cloneTextLineStyle);
            else
                o.textStyle = this.textStyle;
        }
        o.alpha = this.alpha;
        return o;
    }
    get mat() { return this.matrix; }
    get imageSource() { return this.source; }
    set bitmapData(n) {
        if (n != this.source) {
            if (this.source && this.source instanceof BitmapData)
                this.source.removeEventListener(BitmapData.IMAGE_LOADED, this.onImageLoaded);
            this.source = n;
            this.source.addEventListener(BitmapData.IMAGE_LOADED, this.onImageLoaded);
            this.canvas = this.source.htmlCanvas;
            this.dirty = true;
        }
    }
    get centerInto() { return this.center; }
    set centerInto(n) {
        if (n != this.center) {
            this.center = n;
            this.dirtyMatrix = true;
        }
    }
    get targetWidth() { return this.targetW; }
    set targetWidth(n) {
        if (n != this.targetW) {
            this.targetW = n;
            this.dirtyMatrix = true;
        }
    }
    get targetHeight() { return this.targetW; }
    set targetHeight(n) {
        if (n != this.targetH) {
            this.targetH = n;
            this.dirtyMatrix = true;
        }
    }
    get x() { return this.matrix.x; }
    set x(n) {
        if (this.x != n) {
            this.matrix.x = n;
            this.dirtyMatrix = true;
        }
    }
    get y() { return this.matrix.y; }
    set y(n) {
        if (this.y != n) {
            this.matrix.y = n;
            this.dirtyMatrix = true;
        }
    }
    get scaleX() { return this.matrix.scaleX; }
    set scaleX(n) {
        if (this.scaleX != n) {
            this.matrix.scaleX = n;
            this.dirtyMatrix = true;
        }
    }
    get scaleY() { return this.matrix.scaleY; }
    set scaleY(n) {
        if (this.scaleY != n) {
            this.matrix.scaleY = n;
            this.dirtyMatrix = true;
        }
    }
    get rotation() { return this.matrix.rotation; }
    set rotation(n) {
        if (this.rotation != n) {
            this.rotationInDegree = n;
            this.matrix.rotation = n;
            this.dirtyMatrix = true;
        }
    }
    
    apply(context, path, target) {
        let canvas = this.canvas;
        if (this.source instanceof BitmapData) {
            canvas = this.source.htmlCanvas;
            if (this.source instanceof Video) {
                this.dirty = this.source.update();
            }
        }
        else {
            canvas = this.source;
        }
        if (this.dirty) {
            this.patternCanvas = context.createPattern(canvas, "repeat");
            this.dirty = false;
        }
        if (!this.patternCanvas)
            return;
        this.targetW = target.width;
        this.targetH = target.height;
        //-----------------------------------
        var w = canvas.width;
        var h = canvas.height;
        let tw = target.width * target.scaleX;
        let th = target.height * target.scaleY;
        if (this.dirtyMatrix) {
            this.matrix.identity();
            let stx = 1, sty = 1;
            if (this.applyTargetScale) {
                stx = target.scaleX;
                sty = target.scaleY;
            }
            let cropRatio = 1;
            let sx = 1, sy = 1;
            if (this.crop) {
                let s = tw / w;
                w *= s;
                h *= s;
                if (h < th) {
                    s = th / h;
                    w *= s;
                    h *= s;
                }
                sx = w / canvas.width;
                sy = w / canvas.width;
                this.matrix.scale(sx * target.inverseW / target.scaleX, sy * target.inverseH / target.scaleY);
                this.matrix.translate(-((w - tw) / sx) * 0.5, -((h - th) / sy) * 0.5);
                this.matrix.translate(((w) / sx) / 2, (h / sy) / 2);
                this.matrix.scale(this.scaleX * stx, this.scaleY * sty);
                this.matrix.rotate(this.rotation / FillStroke.radian);
                this.matrix.translate(-(w / sx) / 2, -(h / sy) / 2);
                this.matrix.translate(this.x, this.y);
            }
            else {
                this.matrix.scale(sx * stx * target.inverseW * this.scaleX, sy * sty * target.inverseH * this.scaleY);
                this.matrix.rotate(this.rotation / FillStroke.radian);
                this.matrix.translate(this.x, this.y);
            }
            this.dirtyMatrix = false;
        }
        super.apply(context, path, target);
        let pattern = this.patternCanvas;
        pattern.setTransform(this.matrix.domMatrix);
        context[this.styleType] = pattern;
    }
}
//# sourceMappingURL=Pattern.js.map

class SolidFill extends Solid {
    constructor(r = "#000000", g = null, b = null, a = null) {
        super(r, g, b, a);
        this.styleType = "fillStyle";
    }
    get dataString() {
        return this.color.REGISTER_ID;
    }
    static fromDataString(data) {
        return new SolidFill(ObjectLibrary.instance.getObjectByRegisterId(data));
    }
    apply(context, path, target) {
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fill(path.path, this.fillPathRule);
    }
}
//# sourceMappingURL=SolidFill.js.map
class GradientFill extends Gradient {
    constructor(gradient, isLinear = true) {
        super(gradient, isLinear);
        this.styleType = "fillStyle";
    }
    get dataString() {
        var linear = 0;
        if (this.isLinear)
            linear = 1;
        return this.gradient.REGISTER_ID + "," + linear;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new GradientFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1");
    }
    apply(context, path, target) {
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fill(path.path, this.fillPathRule);
    }
}
//# sourceMappingURL=GradientFill.js.map
class BitmapFill extends FillStroke {
    constructor(bd, centerInto = true) {
        super();
        this.centerInto = false;
        this.x = 0;
        this.y = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.rotation = 0;
        this.bd = bd;
        this.centerInto = centerInto;
        this.styleType = "fillStyle";
    }
    get dataString() {
        var centerInto = 0;
        if (this.centerInto)
            centerInto = 1;
        return this.bd.REGISTER_ID + "," + centerInto;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new BitmapFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1");
    }
    clone(cloneMedia = false, cloneLineStyle = true) {
        var o;
        if (cloneMedia)
            o = new BitmapFill(this.bd.clone());
        else
            o = new BitmapFill(this.bd);
        o.x = this.x;
        o.y = this.y;
        o.scaleX = this.scaleX;
        o.scaleY = this.scaleY;
        o.rotation = this.rotation;
        if (this.lineStyle) {
            if (cloneLineStyle)
                o.lineStyle = this.lineStyle.clone();
            else
                o.lineStyle = this.lineStyle;
        }
        return o;
    }
    apply(context, path, target) {
        const bd = this.bd.htmlCanvas;
        context.save(); // do not delete ! need it for mouseevent
        context.clip(path.path);
        context.scale(target.inverseW * this.scaleX, target.inverseH * this.scaleY);
        context.translate(target.xAxis, target.yAxis);
        context.rotate(this.rotation);
        if (this.centerInto)
            context.translate((target.width - bd.width) * 0.5, (target.height - bd.height) * 0.5);
        context.translate(this.x, this.y);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.drawImage(bd, 0, 0);
        context.restore(); // do not delete ! need it for mouseevent
    }
}
//# sourceMappingURL=BitmapFill.js.map
class PatternFill extends Pattern {
    constructor(source, crop = true, applyTargetScale = false) {
        super(source, crop, applyTargetScale);
        this.styleType = "fillStyle";
    }
    get dataString() {
        var crop = 0;
        var targetScale = 0;
        if (this.crop)
            crop = 1;
        if (this.applyTargetScale)
            targetScale = 1;
        return this.source.REGISTER_ID + "," + crop + "," + targetScale;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new PatternFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1", t[1] == "1");
    }
    apply(context, path, target) {
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fill(path.path, this.fillPathRule);
    }
}
//# sourceMappingURL=PatternFill.js.map
class BitmapCacheFill extends FillStroke {
    constructor(bd, centerInto = true) {
        super();
        this.bd = bd;
        this.styleType = "fillStyle";
    }
    get width() { return this.bd.width; }
    get height() { return this.bd.height; }
    apply(context, path, target) {
        context.drawImage(this.bd.htmlCanvas, 0, 0);
    }
}
//# sourceMappingURL=BitmapCacheFill.js.map
class SolidTextFill extends Solid {
    constructor(textStyle, r = "#000000", g = null, b = null, a = null) {
        super(r, g, b, a);
        this.styleType = "fillStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        return this.textStyle.REGISTER_ID + "," + this.color.REGISTER_ID;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new SolidTextFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]));
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fillText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=SolidTextFill.js.map
class GradientTextFill extends Gradient {
    constructor(textStyle, gradient, isLinear = true) {
        super(gradient, isLinear);
        this.styleType = "fillStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        var linear = 0;
        if (this.isLinear)
            linear = 1;
        return this.textStyle.REGISTER_ID + "," + this.gradient.REGISTER_ID + "," + linear;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new GradientTextFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]), t[2] == "1");
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fillText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=GradientTextFill.js.map
class PatternTextFill extends Pattern {
    constructor(textStyle, bd, crop = true, applyTargetScale = false) {
        super(bd, crop, applyTargetScale);
        this.styleType = "fillStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        var crop = 0;
        var targetScale = 0;
        if (this.crop)
            crop = 1;
        if (this.applyTargetScale)
            targetScale = 1;
        return this.textStyle.REGISTER_ID + "," + this.source.REGISTER_ID + "," + crop + "," + targetScale;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new PatternTextFill(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]), t[2] == "1", t[3] == "1");
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.fillText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=PatternTextFill.js.map
class SolidTextStroke extends Solid {
    constructor(textStyle, r = "#000000", g = null, b = null, a = null) {
        super(r, g, b, a);
        this.styleType = "strokeStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        return this.textStyle.REGISTER_ID + "," + this.color.REGISTER_ID;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new SolidTextStroke(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]));
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.strokeText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=SolidTextStroke.js.map
class GradientTextStroke extends Gradient {
    constructor(textStyle, gradient, isLinear = true) {
        super(gradient, isLinear);
        this.styleType = "strokeStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        var linear = 0;
        if (this.isLinear)
            linear = 1;
        return this.textStyle.REGISTER_ID + "," + this.gradient.REGISTER_ID + "," + linear;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new GradientTextStroke(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]), t[2] == "1");
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.strokeText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=GradientTextStroke.js.map
class PatternTextStroke extends Pattern {
    constructor(textStyle, bd, centerInto = true, applyTargetScale = false) {
        super(bd, centerInto, applyTargetScale);
        this.styleType = "strokeStyle";
        this.textStyle = textStyle;
    }
    get dataString() {
        var crop = 0;
        var targetScale = 0;
        if (this.crop)
            crop = 1;
        if (this.applyTargetScale)
            targetScale = 1;
        return this.textStyle.REGISTER_ID + "," + this.source.REGISTER_ID + "," + crop + "," + targetScale;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new PatternTextStroke(ObjectLibrary.instance.getObjectByRegisterId(t[0]), ObjectLibrary.instance.getObjectByRegisterId(t[1]), t[2] == "1", t[3] == "1");
    }
    apply(context, path, target) {
        this.textStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.strokeText(path.text, this.textStyle.offsetX / target.width, this.textStyle.offsetY / target.height);
    }
}
//# sourceMappingURL=PatternTextStroke.js.map
class SolidStroke extends Solid {
    constructor(r = "#000000", g = null, b = null, a = null) {
        super(r, g, b, a);
        this.styleType = "strokeStyle";
    }
    get dataString() {
        return this.color.REGISTER_ID;
    }
    static fromDataString(data) {
        return new SolidStroke(ObjectLibrary.instance.getObjectByRegisterId(data));
    }
    apply(context, path, target) {
        if (this.lineStyle)
            this.lineStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.stroke(path.path);
    }
}
//# sourceMappingURL=SolidStroke.js.map
class GradientStroke extends Gradient {
    constructor(gradient, isLinear = true) {
        super(gradient, isLinear);
        this.styleType = "strokeStyle";
    }
    get dataString() {
        var linear = 0;
        if (this.isLinear)
            linear = 1;
        return this.gradient.REGISTER_ID + "," + linear;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new GradientStroke(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1");
    }
    apply(context, path, target) {
        if (this.lineStyle)
            this.lineStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.stroke(path.path);
    }
}
//# sourceMappingURL=GradientStroke.js.map
class PatternStroke extends Pattern {
    constructor(source, crop = true, applyTargetScale = false) {
        super(source, crop, applyTargetScale);
        this.styleType = "strokeStyle";
    }
    get dataString() {
        var crop = 0;
        var targetScale = 0;
        if (this.crop)
            crop = 1;
        if (this.applyTargetScale)
            targetScale = 1;
        return this.source.REGISTER_ID + "," + crop + "," + targetScale;
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new PatternStroke(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1", t[1] == "1");
    }
    apply(context, path, target) {
        if (this.lineStyle)
            this.lineStyle.apply(context, path, target);
        super.apply(context, path, target);
        if (target.fillStrokeDrawable)
            context.stroke(path.path);
    }
}
//# sourceMappingURL=PatternStroke.js.map
class Path extends RegisterableObject {
    constructor(pathData = null) {
        super();
        this.bounds = { x: 0, y: 0, w: 0, h: 0 };
        this._path = new Path2D();
        if (!pathData)
            this.datas = [];
        else {
            this.datas = pathData;
            this.computePath();
        }
    }
    get dataString() { return this.datas.join(","); }
    static fromDataString(data) {
        var t = data.split(",");
        var t2 = [];
        let i, len = t.length;
        for (i = 0; i < len; i++)
            t2[i] = Number(t[i]);
        return new Path(t2);
    }
    newPath() {
        this._path = new Path2D();
        return this._path;
    }
    isPointInPath(context, px, py, fillrule = "nonzero") {
        return context.isPointInPath(this.path, px, py, fillrule);
    }
    isPointInStroke(context, px, py) {
        return context.isPointInStroke(this.path, px, py);
    }
    isPointInside(context, px, py, isStroke, fillrule = "nonzero") {
        if (isStroke)
            return context.isPointInStroke(this.path, px, py);
        return context.isPointInPath(this.path, px, py, fillrule);
    }
    get originalW() { return this._originalW; }
    get originalH() { return this._originalH; }
    get originalX() { return this._originalX; }
    get originalY() { return this._originalY; }
    moveTo(x, y) { this.datas.push(0, x, y); } //0
    lineTo(x, y) { this.datas.push(1, x, y); } //1
    circle(x, y, radius) {
        //console.log(x,y,radius);
        this.arc(x, y, radius);
    } //2
    quadraticCurveTo(ax, ay, x, y) { this.datas.push(3, ax, ay, x, y); } //3
    rect(x, y, w, h) { this.datas.push(4, x, y, w, h); } //4
    arc(x, y, radius, startAngle = 0, endAngle = Math.PI * 2) {
        //console.log(5,x,y,radius,startAngle,endAngle)
        this.datas.push(5, x, y, radius, startAngle, endAngle);
    } //5
    arcTo(x0, y0, x1, y1, radius) { this.datas.push(6, x0, y0, x1, y1, radius); } //6
    bezierCurveTo(ax0, ay0, ax1, ay1, x1, y1) { this.datas.push(7, ax0, ay0, ax1, ay1, x1, y1); } //7
    static moveTo(path, datas, i) {
        path.moveTo(datas[i + 1], datas[i + 2]);
    }
    static lineTo(path, datas, i) {
        path.lineTo(datas[i + 1], datas[i + 2]);
    }
    static circle(path, datas, i) {
        path.arc(datas[i + 1], datas[i + 2], datas[i + 3], 0, Math.PI * 2);
    }
    static rect(path, datas, i) {
        path.rect(datas[i + 1], datas[i + 2], datas[i + 3], datas[i + 4]);
    }
    static quadraticCurveTo(path, datas, i) {
        path.quadraticCurveTo(datas[i + 1], datas[i + 2], datas[i + 3], datas[i + 4]);
    }
    static arc(path, datas, i) {
        //console.log(datas[i+1],datas[i+2],datas[i+3],datas[i+4],datas[i+5])
        path.arc(datas[i + 1], datas[i + 2], datas[i + 3], datas[i + 4], datas[i + 5]);
    }
    static arcTo(path, datas, i) {
        path.arc(datas[i + 1], datas[i + 2], datas[i + 3], datas[i + 4], datas[i + 5]);
    }
    static bezierCurveTo(path, datas, i) {
        //console.log("bezierCurveTo ",datas[i+1],datas[i+2],datas[i+3],datas[i+4],datas[i+5],datas[i+6])
        path.bezierCurveTo(datas[i + 1], datas[i + 2], datas[i + 3], datas[i + 4], datas[i + 5], datas[i + 6]);
    }
    get path() { return this._path; }
    get geometry() { return this._geom; }
    get pathDatas() { return this.datas; }
    computePath() {
        let i, j, type, minX = 9999999, minY = 9999999, maxX = -9999999, maxY = -9999999;
        let a, b, c, d, e, f;
        let nb, start, val;
        let datas = this.datas;
        let func;
        let count, countOffset;
        let useRadius;
        let minRadius = 9999999, maxRadius = -999999;
        let NB = 0;
        let o;
        const len = datas.length;
        const objByType = Path.objByType;
        //const normalizeData:number[] = datas.concat();
        //datas = normalizeData;
        for (i = 0; i < len; i += (count + 1)) {
            type = datas[i];
            o = objByType[type];
            //console.log(i," type = ",type )
            count = o.count; //countByType[type];
            countOffset = o.countOffset;
            useRadius = o.useRadius;
            start = i + 1;
            nb = count - countOffset;
            nb += start;
            if (useRadius)
                nb--;
            for (j = start; j < nb; j++) {
                val = datas[j];
                if (val < minX)
                    minX = val;
                if (val < minY)
                    minY = val;
                if (val > maxX)
                    maxX = val;
                if (val > maxY)
                    maxY = val;
            }
            if (useRadius) {
                val = datas[nb];
                if (val < minRadius)
                    minRadius = val;
                if (val > maxRadius)
                    maxRadius = val;
            }
        }
        //if(useRadius) nb++
        let dx = maxX - minX;
        let dy = maxY - minY;
        let distRadius = 0;
        if (useRadius) {
            dx = 1; //minRadius;
            dy = 1; //minRadius;
            minX = minY = 0;
            distRadius = 1 + maxRadius - minRadius;
        }
        this._originalW = Math.abs(dx);
        this._originalH = Math.abs(dy);
        this._originalX = minX;
        this._originalY = minY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        //console.log("distRadius => ",distRadius+" = "+maxRadius+" - "+minRadius)
        const path = this._path;
        let startXY, endXY;
        let isXY;
        for (i = 0; i < len; i += (count + 1)) {
            type = datas[i];
            o = objByType[type];
            func = o.func; //funcByType[type];
            count = o.count; //countByType[type];
            countOffset = o.countOffset;
            useRadius = o.useRadius;
            endXY = o.endXY;
            start = i + 1;
            nb = start + count - countOffset;
            //console.log(datas);
            //console.log(minX,minY,dx,dy);
            if (useRadius)
                nb--;
            for (j = start; j < nb; j++) {
                val = datas[j];
                isXY = j < endXY;
                if (j % 2 == 0) {
                    val -= minX;
                    val /= dx;
                }
                else {
                    val -= minY;
                    val /= dy;
                }
                //console.log("datas["+j+"] = ",val);
                datas[j] = val;
            }
            if (useRadius) {
                val = datas[nb];
                //val -= minRadius;
                //val /= (distRadius);
                //console.log("val ",nb," = ",val)
                datas[nb] = val;
                //console.log("datas["+nb+"] = ",val+" ### "+distRadius);
            }
            func(path, datas, start - 1);
        }
        console.log(this.datas);
        this._geom = new Geometry(this);
        return this._geom;
    }
}
Path.objByType = [
    { func: Path.moveTo, count: 2, endXY: 3, countOffset: 0, useRadius: false },
    { func: Path.lineTo, count: 2, endXY: 3, countOffset: 0, useRadius: false },
    { func: Path.arc, count: 3, endXY: 3, countOffset: 0, useRadius: true },
    { func: Path.quadraticCurveTo, count: 4, endXY: 5, countOffset: 0, useRadius: false },
    { func: Path.rect, count: 4, endXY: 3, countOffset: 0, useRadius: false },
    { func: Path.arc, count: 5, endXY: 3, countOffset: 2, useRadius: true },
    { func: Path.arcTo, count: 2, endXY: 3, countOffset: 2, useRadius: true },
    { func: Path.bezierCurveTo, count: 6, endXY: 7, countOffset: 0, useRadius: false }
];
//# sourceMappingURL=Path.js.map
class BitmapPath extends Path {
    constructor(bd, percentOfTheOriginal = 0.055, curveSmooth = 1) {
        super();
        this._outsideBitmap = null;
        this._holeBitmap = null;
        this._outsideVector = null;
        this._holeVector = null;
        this._outsideCurves = null;
        this._holeCurves = null;
        this.bd = bd;
        this.precision = percentOfTheOriginal;
        this.curveSmooth = curveSmooth;
        this.updateBitmapBorders();
        this.generatePath();
    }
    updateBitmapBorders() {
        this.bd.saveData();
        this.bd.setPadding(1, 1, 1, 1);
        this._outsideBitmap = BorderFinder.instance.getBorderFromBitmapData(this.bd);
        this._holeBitmap = BorderFinder.instance.getHoleBorders(this.bd);
        for (var i = 0; i < this._holeBitmap.length; i++)
            this._holeBitmap[i] = this._holeBitmap[i].reverse();
        this.bd.restoreData();
        this.vectorize(this.precision);
        if (this.curveSmooth != 0)
            this.convertLinesToCurves(this.curveSmooth);
    }
    vectorize(percentOfTheOriginal = 0.055) {
        if (percentOfTheOriginal > 1)
            percentOfTheOriginal = 1;
        if (percentOfTheOriginal < 0.0001)
            percentOfTheOriginal = 0.0001;
        var precisionHole = percentOfTheOriginal * 2;
        //console.log("precision = ",percentOfTheOriginal,precisionHole)
        //console.log(this._outsideBitmap.length)
        this._outsideVector = BorderVectorizer.instance.init(this._outsideBitmap.length * percentOfTheOriginal >> 0, this._outsideBitmap);
        //console.log("vectorize : wanted ",(this._outsideBitmap.length*percentOfTheOriginal >> 0)," , got ",this._outsideVector.length)
        //console.log("vector = ",this._outsideVector.length+" VS ",this._outsideBitmap.length)
        this._holeVector = [];
        var i, len = this._holeBitmap.length;
        for (i = 0; i < len; i++) {
            this._holeVector[i] = BorderVectorizer.instance.init(this._holeBitmap[i].length * precisionHole >> 0, this._holeBitmap[i]);
        }
    }
    convertLinesToCurves(smoothLevel = 1) {
        //smoothLevel => a number between 0.1 and 1000
        if (smoothLevel < 0.1)
            smoothLevel = 0.1;
        if (!this.outsideVector)
            this.vectorize(0.065);
        //console.log("vectorLen ",this.outsideVector.length)
        this._outsideCurves = FitCurve.borderToCurve(this.outsideVector, smoothLevel);
        //console.log("curveLen ",this._outsideCurves.length);
        //console.log("vectorToCurveRatio = ",(this._outsideCurves.length / this.outsideVector.length))
        this._holeCurves = [];
        var i, len = this._holeVector.length;
        var j, nb, k = 0;
        var bezier;
        var points = [];
        for (i = 0; i < len; i++) {
            this._holeCurves[i] = FitCurve.borderToCurve(this._holeVector[i], smoothLevel);
        }
    }
    
    generatePath() {
        //this.beginPath();
        let i, len;
        if (this.outsideCurves) {
            //console.log("updateGeometry - curves")
            this.drawCurves(this.outsideCurves);
            if (this.holeCurves && this.holeCurves.length) {
                len = this.holeCurves.length;
                for (i = 0; i < len; i++)
                    this.drawCurves(this.holeCurves[i]);
            }
        }
        else if (this.outsideVector) {
            //console.log("updateGeometry - vector")
            this.drawLines(this.outsideVector);
            if (this.holeVector && this.holeVector.length) {
                len = this.holeVector.length;
                for (i = 0; i < len; i++)
                    this.drawLines(this.holeVector[i]);
            }
        }
        else {
            //console.log("updateGeometry - bitmapBorder")
            this.drawLines(this.outsideBitmap);
            if (this.holeBitmap && this.holeBitmap.length) {
                len = this.holeBitmap.length;
                for (i = 0; i < len; i++)
                    this.drawLines(this.holeBitmap[i]);
            }
        }
        this.computePath();
    }
    drawLines(path) {
        if (!path)
            return;
        this.moveTo(path[0].x, path[0].y);
        let i, len = path.length;
        for (i = 1; i < len; i++)
            this.lineTo(path[i].x, path[i].y);
    }
    drawCurves(path) {
        if (!path)
            return;
        let i, len = path.length;
        let bezier;
        for (i = 0; i < len; i++) {
            bezier = path[i];
            if (i == 0)
                this.moveTo(bezier[0][0], bezier[0][1]);
            this.bezierCurveTo(bezier[1][0], bezier[1][1], bezier[2][0], bezier[2][1], bezier[3][0], bezier[3][1]);
        }
    }
    get outsideBitmap() { return this._outsideBitmap; }
    get holeBitmap() { return this._holeBitmap; }
    get outsideVector() { return this._outsideVector; }
    get holeVector() { return this._holeVector; }
    get outsideCurves() { return this._outsideCurves; }
    get holeCurves() { return this._holeCurves; }
}
//# sourceMappingURL=BitmapPath.js.map

class SquarePath extends Path {
    constructor() {
        super();
        if (!SquarePath._instance)
            SquarePath._instance = this;
        else
            throw new Error("SquarePath is a singleton. You must use SquarePath.instance.");
        this.rect(0, 0, 1, 1);
        this.computePath();
    }
    static get instance() {
        if (!SquarePath._instance)
            new SquarePath();
        return SquarePath._instance;
    }
    static get path() { return SquarePath.instance.path; }
}
//# sourceMappingURL=SquarePath.js.map
class CirclePath extends Path {
    constructor() {
        super();
        if (!CirclePath._instance)
            CirclePath._instance = this;
        else
            throw new Error("CirclePath is a singleton. You must use CirclePath.instance.");
        this.circle(0.5, 0.5, 0.5);
        this.computePath();
    }
    static get instance() {
        if (!CirclePath._instance)
            new CirclePath();
        return CirclePath._instance;
    }
    static get path() { return CirclePath.instance.path; }
}
//# sourceMappingURL=CirclePath.js.map
class Geometry {
    constructor(path = null) {
        this._nbShape = 0;
        this._nbBoundPoint = 0;
        this.bounds = new Rectangle2D();
        if (path)
            this.getPoints(path.pathDatas);
    }
    get trianglePoints() { return this._boundPoints; }
    get triangleIndexs() { return this._indexs; }
    getBounds(target, offsetW, offsetH) {
        let p = this.firstPoint;
        let trans;
        let tx, ty;
        let minX = 99999999;
        let minY = 99999999;
        let maxX = -99999999;
        let maxY = -99999999;
        let m = target.domMatrix;
        let ox = offsetW;
        let oy = offsetH;
        while (p) {
            trans = m.transformPoint(p);
            tx = trans.x;
            ty = trans.y;
            if (tx < minX)
                minX = tx;
            if (tx > maxX)
                maxX = tx;
            if (ty < minY)
                minY = ty;
            if (ty > maxY)
                maxY = ty;
            p = p.next;
        }
        return target.bounds.init(minX - ox, minY - oy, maxX + ox, maxY + oy);
    }
    getPoints(pathDatas) {
        this._boundPoints = [];
        this._shapeXYs = [];
        this._shapeBounds = [];
        this.oldX = 0;
        this.oldY = 0;
        let i = 0, len = pathDatas.length, NB, count, type, start;
        let o;
        while (i < len) {
            type = pathDatas[i++];
            switch (type) {
                case 0: //moveTo
                    this.moveTo(pathDatas[i++], pathDatas[i++]);
                    break;
                case 1: //lineTo
                    this.lineTo(pathDatas[i++], pathDatas[i++]);
                    break;
                case 2: //circle
                    this.circle(pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
                case 3: //quadraticCurveTo
                    this.quadraticCurveTo(pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
                case 4: //rect
                    this.rect(pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
                case 5: //arc
                    this.arc(pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
                case 6: //arcTo
                    this.arcTo(pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
                case 7: //bezierCurveTo
                    this.bezierCurveTo(pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++], pathDatas[i++]);
                    break;
            }
        }
    }
    triangulate() {
        this._indexs = [];
        this.endProcess();
        this._indexs = [];
        var i, len = this._nbShape;
        for (i = 0; i < len; i++)
            this._indexs[i] = EarCutting.instance.computeTriangles(this._shapeXYs[i]);
    }
    endProcess() {
        if (this._nbShape != 0) {
            let o;
            this._shapeBounds[this._nbShape - 1] = o = { minX: this.minX, minY: this.minY, maxX: this.maxX, maxY: this.maxY };
        }
    }
    defineNewShape() {
        this.endProcess();
        this.oldX = 0;
        this.oldY = 0;
        this._shapePoints = [];
        this._shapeXY = [];
        this._boundPoints[this._nbShape] = this._shapePoints;
        this._shapeXYs[this._nbShape] = this._shapeXY;
        this._nbShape++;
        //console.log(this._nbShape)
        this._nbBoundPoint = 0;
    }
    registerPoint(px, py) {
        if (px < this.minX)
            this.minX = px;
        if (px > this.maxX)
            this.maxX = px;
        if (py < this.minY)
            this.minY = py;
        if (py > this.maxY)
            this.maxY = py;
        this.oldX = px;
        this.oldY = py;
        var p = this.lastPoint;
        this._shapeXY.push(px, py);
        this._shapePoints[this._nbBoundPoint++] = this.lastPoint = new DOMPoint(px, py, 0, 1);
        if (p)
            p.next = this.lastPoint;
        this.lastPoint.prev = p;
        if (!this.firstPoint)
            this.firstPoint = this.lastPoint;
    }
    moveTo(px, py) {
        this.defineNewShape();
        this.registerPoint(px, py);
    }
    lineTo(px, py) {
        this.registerPoint(px, py);
    }
    arcTo(x1, y1, x2, y2, radius) {
        var x0 = this.oldX;
        var y0 = this.oldY;
        let dx = x1 - x0;
        let dy = y1 - y0;
        let d = Math.sqrt(dx * dx + dy * dy) - radius;
        let a = Math.atan2(dy, dx);
        let _x0 = x0 + Math.cos(a) * d;
        let _y0 = y0 + Math.sin(a) * d;
        dx = x2 - x1;
        dy = y2 - y1;
        a = Math.atan2(dy, dx);
        let _x1 = x1 + Math.cos(a) * radius;
        let _y1 = y1 + Math.sin(a) * radius;
        this.quadraticCurveTo(x1, y1, _x1, _y1);
    }
    arc(px, py, radius, startAngle, endAngle) {
        this.defineNewShape();
        let da = Math.abs(endAngle - startAngle);
        let pi4 = Math.PI / 8;
        this.registerPoint(px + Math.cos(startAngle) * radius, py + Math.sin(startAngle) * radius);
        let n = 0;
        while (n + pi4 < da) {
            n += pi4;
            this.registerPoint(px + Math.cos(startAngle + n) * radius, py + Math.sin(startAngle + n) * radius);
        }
        this.registerPoint(px + Math.cos(startAngle + da) * radius, py + Math.sin(startAngle + da) * radius);
    }
    circle(px, py, radius) {
        this.arc(px, py, radius, 0, Math.PI * 2);
    }
    rect(x, y, w, h) {
        this.defineNewShape();
        this.registerPoint(x, y);
        this.registerPoint(x + w, y);
        this.registerPoint(x + w, y + h);
        this.registerPoint(x, y + h);
    }
    getQuadraticCurveLength(ax, ay, x1, y1) {
        var x0 = this.oldX;
        var y0 = this.oldY;
        let ox = x0;
        let oy = y0;
        let dx, dy, d = 0;
        let dist = 0;
        let i, nb = 10;
        let px, py, t;
        for (i = 1; i < nb; i++) {
            t = i / nb;
            px = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * ax + t * t * x1;
            py = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * ay + t * t * y1;
            dx = px - ox;
            dy = py - oy;
            dist += Math.sqrt(dx * dx + dy * dy);
            ox = px;
            oy = py;
        }
        dx = x1 - ox;
        dy = y1 - oy;
        dist += Math.sqrt(dx * dx + dy * dy);
        return dist;
    }
    quadraticCurveTo(ax, ay, x1, y1) {
        var x0 = this.oldX;
        var y0 = this.oldY;
        let n = Math.ceil(this.getQuadraticCurveLength(ax, ay, x1, y1) / Geometry.curvePointDistance);
        let i, nb = Math.max(Math.min(n, Geometry.curvePointMax), 4); //GraphicGeometryTriangulator.curvePointMax;
        let px, py, t;
        for (i = 1; i <= nb; i++) {
            t = i / nb;
            px = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * ax + t * t * x1;
            py = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * ay + t * t * y1;
            this.registerPoint(px, py);
        }
    }
    getBezierCurveLength(ax0, ay0, ax1, ay1, x1, y1) {
        var x0 = this.oldX;
        var y0 = this.oldY;
        let i, nb = 5;
        let px, py, t, cX, bX, aX, cY, bY, aY;
        let ox = x0;
        let oy = y0;
        let dx, dy, d = 0;
        let dist = 0;
        for (i = 1; i < nb; i++) {
            t = i / nb;
            cX = 3 * (ax0 - x0);
            bX = 3 * (ax1 - ax0) - cX;
            aX = x1 - x0 - cX - bX;
            cY = 3 * (ay0 - y0);
            bY = 3 * (ay1 - ay0) - cY;
            aY = y1 - y0 - cY - bY;
            px = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + x0;
            py = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + y0;
            dx = px - ox;
            dy = py - oy;
            d += Math.sqrt(dx * dx + dy * dy);
            ox = px;
            oy = py;
        }
        dx = x1 - ox;
        dy = y1 - oy;
        d += Math.sqrt(dx * dx + dy * dy);
        return d;
    }
    bezierCurveTo(ax0, ay0, ax1, ay1, x1, y1) {
        var x0 = this.oldX;
        var y0 = this.oldY;
        var n = Math.ceil(this.getBezierCurveLength(ax0, ay0, ax1, ay1, x1, y1) / Geometry.curvePointDistance);
        var i, nb = n; //Math.max(Math.min(n,GraphicGeometryTriangulator.curvePointMax),5)//GraphicGeometryTriangulator.curvePointMax;
        var px, py, t, cX, bX, aX, cY, bY, aY;
        for (i = 1; i <= nb; i++) {
            t = i / nb;
            cX = 3 * (ax0 - x0);
            bX = 3 * (ax1 - ax0) - cX;
            aX = x1 - x0 - cX - bX;
            cY = 3 * (ay0 - y0);
            bY = 3 * (ay1 - ay0) - cY;
            aY = y1 - y0 - cY - bY;
            px = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + x0;
            py = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + y0;
            this.registerPoint(px, py);
        }
    }
}
Geometry.curvePointMax = 5;
Geometry.curvePointDistance = 10;
//# sourceMappingURL=Geometry.js.map
class RenderStackElement extends RegisterableObject {
    constructor(element, mouseEnabled = true) {
        super();
        this.enabled = true;
        this.lastPath = null;
        this.lastFillStroke = null;
        this.value = element;
        this.mouseEnabled = mouseEnabled;
        this.isShape = this.value instanceof Shape;
        if (this.isShape)
            return;
        this.isPath = this.value instanceof Path;
        this.isTextPath = this.value instanceof TextPath;
        if (this.isPath || this.isTextPath)
            return;
        this.isPathFill = this.value instanceof SolidFill ||
            this.value instanceof GradientFill ||
            this.value instanceof PatternFill ||
            this.value instanceof BitmapFill || this.value instanceof BitmapCacheFill;
        this.isPathStroke = this.value instanceof SolidStroke ||
            this.value instanceof GradientStroke ||
            this.value instanceof PatternStroke;
        this.isTextFill = this.value instanceof SolidTextFill ||
            this.value instanceof GradientTextFill ||
            this.value instanceof PatternTextFill;
        this.isTextStroke = this.value instanceof SolidTextStroke ||
            this.value instanceof GradientTextStroke ||
            this.value instanceof PatternTextStroke;
        this.isTextFillStroke = this.value instanceof SolidTextFill ||
            this.value instanceof GradientTextFill ||
            this.value instanceof PatternTextFill ||
            this.value instanceof SolidTextStroke ||
            this.value instanceof GradientTextStroke ||
            this.value instanceof PatternTextStroke;
        this.isPathFillStroke = this.value instanceof SolidStroke ||
            this.value instanceof GradientStroke ||
            this.value instanceof PatternStroke ||
            this.value instanceof SolidFill ||
            this.value instanceof GradientFill ||
            this.value instanceof PatternFill ||
            this.value instanceof BitmapFill;
        this.isStroke = this.isTextStroke || this.isPathStroke;
    }
    get dataString() {
        var mouseEnabled = 0;
        var lastPath = "0";
        var lastFillStroke = "0";
        if (this.mouseEnabled)
            mouseEnabled = 1;
        if (this.lastPath)
            lastPath = this.lastPath.REGISTER_ID;
        if (this.lastFillStroke)
            lastFillStroke = this.lastFillStroke.REGISTER_ID;
        return [this.value.REGISTER_ID, mouseEnabled, lastPath, lastFillStroke, Number(this.enabled)].join(",");
    }
    static fromDataString(data) {
        var t = data.split(",");
        var r = new RenderStackElement(ObjectLibrary.instance.getObjectByRegisterId(t[0]), t[1] == "1");
        if (t[2] != "0")
            r.lastPath = ObjectLibrary.instance.getObjectByRegisterId(t[2]);
        if (t[3] != "0")
            r.lastFillStroke = ObjectLibrary.instance.getObjectByRegisterId(t[3]);
        r.enabled = t[4] == "1";
        return r;
    }
    clone() {
        var o = new RenderStackElement(this.value, this.mouseEnabled);
        o.init(this.lastPath, this.lastFillStroke);
        return o;
    }
    init(lastPath, lastFillStroke) {
        this.lastPath = lastPath;
        this.lastFillStroke = lastFillStroke;
    }
}
//# sourceMappingURL=RenderStackElement.js.map
class RenderStack extends RegisterableObject {
    constructor() {
        super();
        this.offsetW = 0;
        this.offsetH = 0;
        this._elements = [];
    }
    get dataString() {
        var s = "";
        var lastPath = "0";
        var lastFillStroke = "0";
        if (this.lastPath)
            lastPath = this.lastPath.REGISTER_ID;
        if (this.lastFillStroke)
            lastFillStroke = this.lastFillStroke.REGISTER_ID;
        s = lastPath + "," + lastFillStroke + "#";
        var i, len = this._elements.length;
        if (len == 0)
            return "";
        //console.log("renderStack.elements.length = ",len);
        for (i = 0; i < len; i++) {
            if (i > 0)
                s += ",";
            s += this._elements[i].REGISTER_ID;
        }
        return s;
    }
    static fromDataString(data) {
        var t2 = data.split("#");
        var t3 = t2[0].split(",");
        var t = t2[1].split(",");
        var i, len = t.length;
        var r = new RenderStack();
        for (i = 0; i < len; i++) {
            r.elements[i] = ObjectLibrary.instance.getObjectByRegisterId(t[i]);
        }
        if (t3[0] != "0")
            r.lastPath = ObjectLibrary.instance.getObjectByRegisterId(t3[0]);
        if (t3[1] != "0")
            r.lastFillStroke = ObjectLibrary.instance.getObjectByRegisterId(t3[1]);
        return r;
    }
    get elements() { return this._elements; }
    clone() {
        var o = new RenderStack();
        var i, len = this.elements.length;
        for (i = 0; i < len; i++)
            o.elements[i] = this.elements[i].clone();
        return o;
    }
    //##############
    //la renderStack ne peut pas etre une linked-list de telle manire qu'on puisse cloner le tableau contenant les objets sans cloner les objets
    //et de cloner un lment dans le tableau sans affecter tout le to
    //#################
    push(renderStackElement, mouseEnabled = true) {
        var o = new RenderStackElement(renderStackElement, mouseEnabled);
        this._elements.push(o);
        if (renderStackElement instanceof Path || renderStackElement instanceof TextPath)
            this.lastPath = renderStackElement;
        else if (renderStackElement instanceof FillStroke)
            this.lastFillStroke = renderStackElement;
        o.init(this.lastPath, this.lastFillStroke);
        return o;
    }
    updateWithHitTest(context, target, mouseX = Number.MAX_VALUE, mouseY = Number.MAX_VALUE, updateFromShape = false) {
        let o;
        let path;
        let hitTest = false;
        let fillStroke;
        let obj;
        let i, nb = this.elements.length;
        let b;
        for (i = 0; i < nb; i++) {
            o = this.elements[i];
            context.save();
            if (o.enabled) {
                if (o.isShape) {
                    b = o.value.apply(context, target, mouseX, mouseY);
                    if (!hitTest)
                        hitTest = b;
                }
                else {
                    if (o.isPath || o.isTextPath)
                        path = o.value;
                    else {
                        o.value.apply(context, path, target);
                        if (!hitTest && o.mouseEnabled && target.useComplexHitTest)
                            hitTest = path.isPointInside(context, mouseX, mouseY, o.isStroke);
                    }
                }
            }
            context.restore();
        }
        if (!updateFromShape && target.cacheAsBitmap) {
            this.updateBounds(target);
            target.bitmapCache.draw(context, this.offsetW, this.offsetH);
        }
        if (target.mouseIsOver == false && hitTest)
            target.onMouseOver();
        if (target.mouseIsOver && hitTest == false)
            target.onMouseOut();
        return hitTest;
    }
    update(context, target, updateFromShape = false) {
        let o;
        let path;
        let fillStroke;
        let obj;
        if (updateFromShape || target.cacheAsBitmap == false) {
            let i, nb = this.elements.length;
            for (i = 0; i < nb; i++) {
                o = this.elements[i];
                context.save();
                if (o.enabled) {
                    if (o.isPath || o.isTextPath)
                        path = o.value;
                    else
                        o.value.apply(context, path, target);
                }
                context.restore();
            }
        }
        else {
            this.updateBounds(target);
            target.bitmapCache.draw(context, this.offsetW, this.offsetH);
        }
        return false;
    }
    
    updateBounds(target) {
        
        let o;
        let path;
        let text;
        let hitTest = false;
        let fillStroke;
        //target.resetBoundsOffsets();
        let offsetW = 0;
        let offsetH = 0;
        let lineW = 0;
        let i, nb = this.elements.length;
        for (i = 0; i < nb; i++) {
            o = this.elements[i];
            if (o.enabled) {
                if (o.isPath)
                    path = o.value;
                else if (o.isTextPath)
                    text = o.value;
                else {
                    fillStroke = o.value;
                    if (fillStroke.offsetW > offsetW)
                        offsetW = fillStroke.offsetW;
                    if (fillStroke.offsetH > offsetH)
                        offsetH = fillStroke.offsetH;
                    if (fillStroke.lineWidth > lineW)
                        lineW = fillStroke.lineWidth;
                }
            }
        }
        var r = path.geometry.getBounds(target, (offsetW + lineW) * Math.sqrt(2), (offsetH + lineW) * Math.sqrt(2));
        this.offsetW = lineW + (offsetW) * (Math.sqrt(2) + 1);
        this.offsetH = lineW + (offsetH) * (Math.sqrt(2) + 1);
        return r;
    }
    updateCache(context, target) {
        let o;
        let path;
        let text;
        let i, nb = this.elements.length;
        for (i = 0; i < nb; i++) {
            o = this.elements[i];
            context.save();
            if (o.enabled) {
                if (o.isPath)
                    path = o.value;
                else if (o.isTextPath)
                    text = o.value;
                else {
                    if (o.isTextFillStroke)
                        o.value.apply(context, text, target);
                    else
                        o.value.apply(context, path, target);
                }
            }
            context.restore();
        }
    }
}
//# sourceMappingURL=RenderStack.js.map

class Shape extends RegisterableObject {
    constructor(x, y, w, h, renderStack) {
        super();
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.renderStack = renderStack;
    }
    get dataString() {
        return [this.x, this.y, this.w, this.h, this.renderStack.REGISTER_ID].join(",");
    }
    static fromDataString(data) {
        var t = data.split(",");
        return new Shape(Number(t[0]), Number(t[1]), Number(t[2]), Number(t[3]), ObjectLibrary.instance.getObjectByRegisterId(t[4]));
    }
    apply(context, target, mouseX = Number.MAX_VALUE, mouseY = Number.MAX_VALUE) {
        context.save();
        context.translate(this.x * target.inverseW, this.y * target.inverseH);
        context.scale(this.w / target.width, this.h / target.height);
        var b;
        //console.log(target instanceof Display2D)
        if (target.mouseEnabled)
            b = this.renderStack.updateWithHitTest(context, target, mouseX, mouseY, true);
        else {
            b = this.renderStack.update(context, target, true);
        }
        context.restore();
        return b;
    }
}
//# sourceMappingURL=Shape.js.map
class Display2D extends Matrix2D {
    constructor(w, h, renderStack = null) {
        super();
        this._cacheAsBitmap = false;
        this.width = 1;
        this.height = 1;
        this.alpha = 1;
        this.inverseW = 1; //used for filling process;
        this.inverseH = 1; //used for filling process;
        this.mouseIsOver = false;
        this.mouseEnabled = true;
        this.useBasicHitTest = false;
        this._display2dName = "o" + (Display2D.display2dIndex++);
        this.width = w;
        this.height = h;
        if (!renderStack)
            this.renderStack = new RenderStack();
        else
            this.renderStack = renderStack;
        this._bounds = new Rectangle2D(0, 0, w, h);
        this.cache = new BitmapCache(this);
    }
    get dataString() {
        var datas = super.dataString;
        datas += "#";
        datas += [this.width, this.height, this.alpha, this.renderStack.REGISTER_ID].join(",");
        return datas;
    }
    static fromDataString(data, target = null) {
        var t = data.split("#")[2].split(",");
        console.log(t);
        var o;
        if (!target)
            o = new Display2D(Number(t[0]), Number(t[1]), ObjectLibrary.instance.getObjectByRegisterId(t[3]));
        else
            o = target;
        o.alpha = Number(t[2]);
        Matrix2D.fromDataString(data, o);
        return o;
    }
    
    get fillStrokeDrawable() { return this._cacheAsBitmap == false || this.cache.needsUpdate == true; }
    get display2dName() { return this._display2dName; }
    get useComplexHitTest() { return this.useBasicHitTest == false && this.mouseEnabled; }
    setStage(stage) {
        this._stage = stage;
        if (stage)
            this.mouse = stage.mouseControler;
        else
            this.mouse = null;
    }
    get stage() { return this._stage; }
    align(displayAlign = Align.CENTER) {
        this.xAxis = this.width * displayAlign.x;
        this.yAxis = this.height * displayAlign.y;
    }
    stack(renderStackElement) {
        return this.renderStack.push(renderStackElement);
    }
    get cacheAsBitmap() { return this._cacheAsBitmap; }
    set cacheAsBitmap(b) {
        if (b != this._cacheAsBitmap) {
            this._cacheAsBitmap = b;
            if (b)
                this.cache.needsUpdate = true;
        }
    }
    get bitmapCache() { return this.cache; }
    get bounds() { return this._bounds; }
    get realAlpha() {
        if (!this.parent)
            console.log(this);
        return this.parent.realAlpha * this.alpha;
    }
    get realX() { return this.parent.realX + this.x; }
    ;
    get realY() { return this.parent.realY + this.y; }
    ;
    get realScaleX() { return this.parent.realScaleX * this.scaleX; }
    ;
    get realScaleY() { return this.parent.realScaleY * this.scaleY; }
    ;
    get realRotation() { return this.parent.realRotation + this.rotation; }
    ;
    onMouseOver() {
        this.mouseIsOver = true;
        this.dispatchEvent(Display2D.MOUSE_OVER);
    }
    onMouseOut() {
        this.mouseIsOver = false;
        this.dispatchEvent(Display2D.MOUSE_OUT);
    }
    resetBoundsOffsets() {
        this.offsetW = this.offsetH = 0;
    }
    update(context) {
        this.identity();
        this.inverseW = 1 / this.width;
        this.inverseH = 1 / this.height;
        context.save();
        if (this.parent)
            this.multiply(this.parent);
        let m = this.currentTransform = this.applyTransform();
        context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
        this.cache.updateCache();
        if (this.mouseEnabled && this.mouse)
            this.renderStack.updateWithHitTest(context, this, this.mouse.x, this.mouse.y);
        else
            this.renderStack.update(context, this);
        context.restore();
    }
}
Display2D.display2dIndex = 0;
Display2D.MOUSE_OVER = "MOUSE_OVER";
Display2D.MOUSE_OUT = "MOUSE_OUT";
Display2D.CLICK = "CLICK";
Display2D.pathManager = new Path();
//# sourceMappingURL=Display2D.js.map

class BitmapCache extends BitmapData {
    constructor(target, renderStackElement = null) {
        super(1, 1);
        this.needsUpdate = false;
        this.target = target;
        this.renderStackElement = renderStackElement;
    }
    draw(context, offsetW, offsetH) {
        const target = this.target;
        context.save();
        if (!this.renderStackElement)
            context.globalAlpha = target.realAlpha;
        context.scale(1 / (this.width - offsetW * 2), 1 / (this.height - offsetH * 2));
        context.translate(-offsetW, -offsetH);
        context.drawImage(this.canvas, 0, 0);
        context.restore();
    }
    
    updateCache(forceUpdate = false) {
        if (this.needsUpdate == true || forceUpdate) {
            //console.log("updateCache")
            const w = this.target.width * this.target.scaleX;
            const h = this.target.height * this.target.scaleY;
            const context = this.context;
            const target = this.target;
            if (this.renderStackElement) {
                if (this.renderStackElement.value instanceof FillStroke) {
                    const o = this.renderStackElement.value;
                    this.width = w + o.offsetW * 2;
                    this.height = h + o.offsetH * 2;
                    context.save();
                    var m = new DOMMatrix().translate(o.offsetW, o.offsetH).scale(w, h);
                    context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                    o.apply(context, this.renderStackElement.lastPath, target);
                    this.context.restore();
                }
            }
            else {
                const renderStack = target.renderStack;
                renderStack.updateBounds(target);
                this.width = w + renderStack.offsetW * 2;
                this.height = h + renderStack.offsetH * 2;
                context.save();
                var m = new DOMMatrix().translate(renderStack.offsetW, renderStack.offsetH).scale(w, h);
                context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                let o;
                let path;
                let text;
                let elements = target.renderStack.elements;
                let i, nb = target.renderStack.elements.length;
                for (i = 0; i < nb; i++) {
                    o = target.renderStack.elements[i];
                    context.save();
                    if (o.enabled) {
                        if (o.isShape)
                            o.value.apply(context, target);
                        else {
                            if (o.isPath)
                                path = o.value;
                            else if (o.isTextPath)
                                text = o.value;
                            else {
                                if (o.isTextFillStroke)
                                    o.value.apply(context, text, target);
                                else
                                    o.value.apply(context, path, target);
                            }
                        }
                    }
                    context.restore();
                }
                context.restore();
            }
            this.needsUpdate = false;
        }
    }
}
//# sourceMappingURL=BitmapCache.js.map

class Group2D extends Display2D {
    constructor() {
        super(1, 1);
        
        this._numChildren = 0;
        this._children = [];
    }
    get dataString() {
        var data = super.dataString;
        data += "#";
        var i, len = this._children.length;
        for (i = 0; i < len; i++) {
            if (i > 0)
                data += ",";
            data += this._children[i].REGISTER_ID;
        }
        return data;
    }
    static fromDataString(data, target = null) {
        var params = data.split("#");
        //console.log("params = ",params);
        var t = params[3].split(",");
        var o;
        if (!target)
            o = new Group2D();
        else
            o = target;
        Display2D.fromDataString(data, o);
        var i, len = t.length;
        for (i = 0; i < len; i++)
            o.appendChild(ObjectLibrary.instance.getObjectByRegisterId(t[i]));
        return o;
    }
    setStage(stage) {
        super.setStage(stage);
        let i, nb = this._numChildren;
        for (i = 0; i < nb; i++)
            this._children[i].setStage(stage);
    }
    appendChild(element) {
        this._children[this._numChildren++] = element;
        element.parent = this;
        console.log("Group.appendChild ", element, this.stage);
        element.setStage(this.stage);
        return element;
    }
    removeChild(element) {
        const id = this._children.lastIndexOf(element);
        if (id < 0)
            return null;
        this._children.splice(id, 1);
        this._numChildren--;
        element.parent = null;
        this.setStage(null);
        return element;
    }
    get numChildren() { return this._numChildren; }
    get children() { return this._children; }
    update(context) {
        let alpha = this.alpha;
        const parent = this.parent;
        const children = this.children;
        this.identity();
        if (parent)
            this.multiply(parent);
        const m = this.applyTransform();
        context.save();
        let i, nb = this._numChildren;
        for (i = 0; i < nb; i++)
            children[i].update(context);
        context.restore();
        return m;
    }
}
//# sourceMappingURL=Group2D.js.map

class Stage2D extends Group2D {
    constructor(w, h, appendOnBody = true) {
        super();
        this._stage = this;
        if (!Browser.canUseOffscreenCanvas) {
            this._canvas = document.createElement("canvas");
            this._output = this._canvas;
            this._output.style.position = "absolute";
            this._outputContext = this._output.getContext("2d");
        }
        else {
            this._canvas = new window.OffscreenCanvas(w, h);
            this._output = document.createElement("canvas");
            this._output.style.position = "absolute";
            if (Browser.canUseImageBitmap)
                this._outputContext = this._output.getContext("bitmaprenderer");
            else
                this._outputContext = this._output.getContext("2d");
        }
        this._canvas.width = this._output.width = w;
        this._canvas.height = this._output.height = h;
        this._context = this._canvas.getContext("2d");
        this._mouseControler = new MouseControler(this._output);
        //console.log("new Stage2D ",w,h,appendOnBody)
        if (appendOnBody)
            document.body.appendChild(this._output);
    }
    get dataString() {
        //this.width = this.canvas.width;
        //this.height = this.canvas.height;
        var o = super.dataString + "###" + this._canvas.width + "," + this._canvas.height;
        //this.width = this.height = 1;
        return o;
    }
    static fromDataString(data) {
        var t = data.split("###");
        var sizes = t[1].split(",");
        data = t[0];
        var t = data.split("#")[2].split(",");
        //console.log("stage data = ",data)
        console.log(data);
        console.log(sizes);
        var o = new Stage2D(Number(sizes[0]), Number(sizes[1]), true);
        Group2D.fromDataString(data, o);
        return o;
    }
    get canvas() { return this._canvas; }
    get context() { return this._context; }
    get mouseControler() { return this._mouseControler; }
    get realAlpha() { return this.alpha; }
    get realX() { return this.x; }
    ;
    get realY() { return this.y; }
    ;
    get realScaleX() { return this.scaleX; }
    ;
    get realScaleY() { return this.scaleY; }
    ;
    get realRotation() { return this.rotation; }
    ;
    drawElements() {
        this._canvas.width = this._canvas.width;
        super.update(this._context);
        if (Browser.canUseImageBitmap) {
            //console.log("drawElements ",this._outputContext)
            createImageBitmap(this._canvas).then((bmp) => this._outputContext.transferFromImageBitmap(bmp));
        }
        else {
            this._outputContext.drawImage(this._canvas, 0, 0);
        }
    }
}
//# sourceMappingURL=Stage2D.js.map
class App {
    
    constructor() {
        var stage = new Stage2D(window.innerWidth, window.innerHeight);
        var contener = new Group2D();
        contener.x = 300;
        contener.y = 100;
        //contener.rotation = -45
        var c0 = new SolidColor(0xff0000);
        var gradient = new GradientColor([c0, new SolidColor(0x0000ff)], null, true);
        //var gradient = new RadialGradientColor();
        //gradient.setColorStep([new SolidColor(0xff0000),new SolidColor(0x0000ff)]);
        var bd = new Img("assets/mire.jpg");
        //bd.loadImage("assets/mire.jpg",true,false)
        //bd.loadImage("assets/tile.jpg",true,true)
        var video = new Video(192 * 4, 108 * 4, "assets/video2.mp4");
        var alphaBd = new Img("assets/alpha.png");
        alphaBd.addEventListener(BitmapData.IMAGE_LOADED, function () {
            var bitmapPath = new BitmapPath(alphaBd);
            var vecto = new Display2D(400, 500);
            vecto.x = -200;
            vecto.stack(bitmapPath);
            vecto.stack(new PatternFill(video));
            //console.log("vecto = ",Path.fromDataString(bitmapPath.dataString));
            contener.appendChild(vecto);
            ObjectLibrary.instance.save();
        });
        //alphaBd.loadImage(,true,false)
        //ObjectLibrary.instance.load("test.txt");
        var fill, stroke, textFill, textStroke;
        var textStyle = new TextStyle("Arial", 100, "px");
        textStyle.lineStyle = new LineStyle(3);
        var solid = new SolidFill("#000000");
        fill = new PatternFill(bd, true, false);
        //fill = new GradientFill(gradient);
        //fill = new BitmapFill(bd,true);
        //fill.filter = new CssFilter().halo(25,"#ff0000")
        var glow = new GlowFilter(25, "#ff0000");
        var filters = new FilterStack().add(glow);
        fill.filters = glow; //filters;
        //textFill = new PatternText(textStyle,bd);
        //textFill = new GradientText(textStyle,gradient);
        textFill = new SolidTextStroke(textStyle, c0);
        //stroke = new SolidStroke("#0000ff");
        //stroke = new PatternStroke(bd,true);
        stroke = new GradientStroke(gradient);
        //stroke.filter = "blur(5px)"
        var lineOption = stroke.lineStyle = new LineStyle();
        lineOption.lineWidth = 15;
        //lineOption.dashLineDist = 10;
        //lineOption.dashHoleDist = 10;
        lineOption.cap = "round";
        lineOption.join = "round";
        //fill.x = 300
        //fill.scaleX = 4;
        //fill.rotation = Math.PI/4
        var redQuad = new RenderStack();
        redQuad.push(SquarePath.instance);
        redQuad.push(new SolidFill(c0));
        var shape = new Shape(50, 450, 50, 100, redQuad);
        var mcs = [];
        var nbMc = 1;
        var i;
        var alpha = 1;
        for (i = 0; i < nbMc; i++) {
            var mc = new Display2D(400, 400);
            mcs[i] = mc;
            //mc.stack(SquarePath.instance);
            mc.stack(CirclePath.instance);
            mc.stack(fill);
            mc.stack(stroke);
            mc.stack(new TextPath("Youpi !"));
            mc.stack(textFill);
            mc.stack(shape);
            mc.align(Align.CENTER);
            mc.x = 200 + i * 20;
            mc.y = 200;
            mc.rotation = 50 + (360 / nbMc) * i;
            //mc.scaleX = 2.5;
            contener.appendChild(mc);
            mc.alpha = alpha;
            //mc.scaleX = 1.5;
            mc.addEventListener(Display2D.MOUSE_OVER, function (e) {
                //console.log("over");
                e.alpha = 0.5; //alpha - 0.25;
            });
            mc.addEventListener(Display2D.MOUSE_OUT, function (e) {
                //console.log("out");
                e.alpha = alpha;
            });
        }
        document.body.onclick = function () {
            for (i = 0; i < nbMc; i++) {
                mcs[i].cacheAsBitmap = !mcs[i].cacheAsBitmap;
            }
        };
        //ObjectLibrary.print();
        stage.appendChild(contener);
        var a = 0;
        function animate() {
            a += 0.01;
            //stroke.lineStyle.dashOffset = (Math.sin(a*0.05))*300
            var pct = Math.sin(a * 5);
            c0.g = Math.abs(pct * 255);
            //mc.scaleX = mc.scaleY = 1 + (Math.sin(a*0.1))*0.5
            //mc.rotation += 1
            //glow.radius = 10 + 25 * pct;
            for (i = 0; i < nbMc; i++) {
                //mcs[i].rotation = -a*100;
                //mcs[i].scaleX = 1 + 1-(c0.g / 255)*(i+1)*(1/nbMc) ;
            }
            //lineOption.dashOffset=pct
            //lineOption.dashLineDist = 5+pct*100;
            //lineOption.dashHoleDist = 10+pct*100;
            //mc.x = 500 + Math.sin(a*0.05)*300
            //fill.rotation -= 0.1;
            stroke.rotation += 0.01;
            //
            //fill.rotation -= 0.01;
            //fill.scaleX = fill.scaleY = 0.5+Math.abs(Math.sin(a)*1.5);
            //fill.x= Math.sin(a * Math.PI/180);
            //gradient.needsUpdate = true;
            stage.drawElements();
            //mc.updateCache()
            //mc.updateCacheWithoutRotation()
            //stage.context.beginPath()
            requestAnimationFrame(animate);
        }
        animate();
    }
}
//# sourceMappingURL=App.js.map

class App2 {
    constructor() {
        var stage;
        ObjectLibrary.instance.load("test.txt", function () {
            ObjectLibrary.print();
            //ObjectLibrary.printElements("RenderStackElement")
            stage = ObjectLibrary.instance.getElementsByName("Stage2D")[0];
            stage.setStage(stage);
            console.log(stage);
            animate();
        });
        function animate() {
            stage.drawElements();
            requestAnimationFrame(animate);
        }
    }
}
//# sourceMappingURL=App2.js.map
class App3 {
    
    constructor() {
        var stage = new Stage2D(800, 600);
        var c0 = new SolidColor(0xff0000);
        var redQuad = new RenderStack();
        redQuad.push(SquarePath.instance);
        redQuad.push(new SolidFill(c0));
        var mc = new Display2D(200, 200, redQuad);
        mc.x = mc.y = 100;
        var group = new Group2D();
        group.x = 200;
        group.appendChild(mc);
        stage.appendChild(group);
        stage.drawElements();
        ObjectLibrary.instance.save();
    }
}
//# sourceMappingURL=App3.js.map

